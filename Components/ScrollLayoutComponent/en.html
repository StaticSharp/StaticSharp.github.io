<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0"><title>Scroll Layout</title><meta property="og:site_name" content="site name"><meta property="og:title" content="Scroll Layout"><meta property="twitter:title" content="Scroll Layout"><meta property="twitter:card" content="summary_large_image"><meta property="og:url" content="http://staticsharp.github.io/Components/ScrollLayoutComponent/en"><meta property="twitter:url" content="http://staticsharp.github.io/Components/ScrollLayoutComponent/en"><meta property="description" content="Контейнер вертикальным и горизонтальным скроллбарами."><meta property="og:description" content="Контейнер вертикальным и горизонтальным скроллбарами."><meta property="twitter:description" content="Контейнер вертикальным и горизонтальным скроллбарами."><meta property="og:type" content="website"><script>function ToCssSize(value) {
    return (value!=undefined) ? value + "px" : ""
}

function DepthToStyle(element) {
    return new Reaction(() => {
        element.style.zIndex = element.Depth
    })
}


function XToStyle(element) {
    return new Reaction(() => {
        element.style.left = ToCssSize(element.X)
    })
}
function YToStyle(element) {
    return new Reaction(() => {
        element.style.top = ToCssSize(element.Y)
    })
}

function WidthToStyle(element) {
    return new Reaction(() => {
        element.style.width = ToCssSize(element.Width)
    })
}

function HeightToStyle(element) {
    return new Reaction(() => {
        element.style.height = ToCssSize(element.Height)
    })
}



function Try(func, defaultValue, exceptions) {
    //console.log("try", func, defaultValue, exceptions)
    try {
        return func()
    } catch (e) {
        console.warn(e)
        if (exceptions == undefined) {
            return defaultValue
        } else {
            for (let i of exceptions) {
                if (e instanceof i) {
                    return defaultValue
                }
            }
            throw e
        }
    }
}
function IsNaNOrNull(value) {
    if (value === null) return true
    return isNaN(value)
}

function Max() {
    let result = undefined
    for (let i of arguments) {
        if (IsNaNOrNull(i)) continue;
        if (result === undefined) {
            result = i
        } else {
            result = Math.max(result, i)
        }
    }
    return result
}

function Min() {
    let result = undefined
    for (let i of arguments) {
        if (IsNaNOrNull(i)) continue;
        if (result === undefined) {
            result = i
        } else {
            result = Math.min(result, i)
        }
    }
    return result
}

function Clamp(value, min, max) {
    return Math.max(min, Math.min(max, value))
}

function Sum() {
    let resultValid = false
    let result = 0
    for (let i of arguments) {
        if (IsNaNOrNull(i)) continue;
        resultValid = true
        result += i
    }
    return resultValid ? result : undefined
}


function First() {
    for (let i of arguments) {
        if (i === undefined) continue;
        if (isNaN(i)) continue;
        if (i === null) continue;
        return i
    }
    return undefined
}


const SpaceTagName = "WS"
const WordTagName = "W"
function _deleteScript() {
    let script = document.currentScript
    let parent = script.parentElement
    parent.removeChild(script)
    return parent
}

var currentParent = undefined

function Constructor() {
    var element = _deleteScript()
    element.Parent = currentParent
    currentParent = element
    
    for (let i of arguments) {
        i(element)
    }

    /*if (element.parentElement) {
        if (element.parentElement.tagName == "OVERLAY") {
            let overlay = element.parentElement
            let parent = overlay.parentElement
            //parent.removeChild(overlay)
            //document.body.appendChild(element)
            element.Parent = parent
            parent.Overlay = element
        } else {
            element.Parent = element.parentElement
        }
    }*/

    return element;
}

function Pop() {
    let element = _deleteScript()
    if (element.Parent) {
        currentParent = element.Parent
    } else {
        delete currentParent
    }
}


function CamelToKebab(value) {
    return value.replace(
        /[A-Z]+(?![a-z])|[A-Z]/g,
        (substring, offset) => (offset ? "-" : "") + substring.toLowerCase()
    )
}


function Create(parent, ...constructors) {
    let primary = constructors[0]
    let tagName = CamelToKebab(primary.name)
    
    let element = document.createElement(tagName)
    parent.appendChild(element)
    element.Parent = parent
    for (let i of constructors) {
        i(element)
    }
    return element;
    
}





function ReactionBase(func) {
    let _this = this

    _this.triggeringProperties = new Set()
    _this.func = func
    
    _this.addTriggeringProperty = function (property) {
        _this.triggeringProperties.add(property)
        property.dependentReactions.add(_this)
    }

    _this.unsubscribeFromTriggeringProperties = function () {
        if (_this.triggeringProperties.size == 0) return

        for (let triggeringProperty of _this.triggeringProperties) {
            triggeringProperty.dependentReactions.delete(_this)
        }
        _this.triggeringProperties.clear()
    }

    _this.execute = function () {
        let oldReaction = Reaction.current
        Reaction.current = _this
        _this.unsubscribeFromTriggeringProperties()

        try {
            let result = _this.func()
            return result
        }
        finally {
            Reaction.current = oldReaction
        }
    }


    //_this.makeDirty = abstract function
    _this.dirtImmune = false
}


function Reaction(func) {
    let _this = this

    ReactionBase.call(_this, func)
    
    _this.makeDirty = function () {
        if (_this.dirtImmune)
            return;
        Reaction.deferred.add(_this)
    }

    if (Reaction.deferred) {
        Reaction.deferred.add(_this)
    } else {
        let d = Reaction.beginDeferred()

        try {
            _this.execute()
        } catch (e) {
            console.warn(e)
        }
        
        d.end()
    }
}

Reaction.prototype = Object.create(ReactionBase.prototype)
Reaction.prototype.constructor = Reaction

Reaction.beginDeferred = function () {
    if (!Reaction.deferred) {
        Reaction.deferred = new Set()
        return {
            end: function () {

                let maxIterations = 64;
                 
                while (Reaction.deferred.size > 0 & maxIterations > 0) {
                    //console.log("Reaction.deferred.end", Reaction.deferred.size)
                    let d = Array.from(Reaction.deferred)
                    for (let reaction of d) {
                        Reaction.deferred.delete(reaction)
                        try {
                            reaction.execute()
                        } catch (e) {
                            console.warn(e)
                        }
                        
                    }
                    maxIterations--
                    //d.forEach(x => x.execute())
                    //Reaction.deferred.clear()
                }

                if (maxIterations == 0) {
                    console.error("Recursive property binding", Reaction.deferred)
                }

                //let l = Reaction.deferred;
                Reaction.deferred = undefined
                //l.forEach(x => x.execute())

                

            }
        };
    }
    return {
        end: function () { }
    };
}


Reaction.beginNonReactive = function () {
    if (!Reaction.current) {
        let oldCurrent = Reaction.current
        Reaction.current = undefined
        return {
            end: function () {
                Reaction.current = oldCurrent
            }
        };
    }
    return {
        end: function () { }
    };
}



function Binding(func, onBecameDirty) {
    //console.log("function Binding(func, onChange)", onChange)
    let _this = this

    ReactionBase.call(_this, func)

    _this.dirty = true
    //_this.onBecameDirty = onBecameDirty

    
    _this.makeDirty = function () {
        if (_this.dirty)
            return

        _this.dirty = true        
        onBecameDirty()
    }
}
Binding.prototype = Object.create(ReactionBase.prototype);
Binding.prototype.constructor = Binding;



function Property(value) {

    let _this = this
    _this.name = ""
    _this.parent = null

    _this.dependentReactions = new Set()
    _this.binding = undefined

    _this.makeDirty = function () {
        _this.binding.makeDirty()
    }
    
    _this.onBindingBecameDirty = function () {
        _this.makeDependentReactionsDirty()
    }

    _this.makeDependentReactionsDirty = function () {
        /********************************************
         a deferred context is reqired here in case
         makeDirty() is called from a callback
         
         window.setTimeout(() => {
            element.Reactive.SomeProperty.makeDirty();
        },50)

         *******************************************/
        var d = Reaction.beginDeferred() 
        _this.dependentReactions.forEach(x => x.makeDirty())
        d.end()
    }

    /*_this.dependsOn = function (property) {
        if (!_this.binding)
            return false
        _this.getValue()
        for (let i of _this.binding.dependencies) {
            if (i == property)
                return true
        }
        for (let i of _this.binding.dependencies) {
            if (i.dependsOn(property))
                return true
        }
        return false
    }

    _this.getRecursiveDependencies = function () {
        let result = new Set();
        if (!_this.binding)
            return result
        _this.getValue()
        
        _this._collectRecursiveDependencies(result)
        return result
    }

    _this._collectRecursiveDependencies = function (set) {
        for (let i of _this.binding.dependencies) {
            set.add(i)
            i._collectRecursiveDependencies(set)
        }
    }*/
    _this.executionInProgress = false
    
    _this.getValue = function() {
        //console.log("getValue")
        
        //console.log("getValue", _this.name, _this.binding?.dirty)

        if (Reaction.current) {
            Reaction.current.addTriggeringProperty(_this)
        }

        if (_this.binding) { //wechat (this.binding?.dirty) not supported
            if (_this.binding.dirty) {
                if (_this.executionInProgress) {


                    if (_this.reactionsWhoReceivedOldValue == undefined) {
                        _this.reactionsWhoReceivedOldValue = new Set()
                    }
                    _this.reactionsWhoReceivedOldValue.add(Reaction.current)                    

                    //console.log("getValue", _this.name, "executionInProgress")

                    return _this.value
                }
                try {
                    var oldValue = _this.value
                    try {
                        _this.executionInProgress = true
                        _this.value = _this.binding.execute()
                        
                    } finally {
                        _this.executionInProgress = false

                        _this.binding.dirty = false
                        //console.log("execute finished ", _this.object, _this.name, oldValue, "->", _this.value)


                        if (_this.reactionsWhoReceivedOldValue) {

                            if (_this.value !== oldValue) {

                                //var reactionsToPrint = Array.from(_this.reactionsWhoReceivedOldValue).map(x => x.func.name)
                                //console.log("ReactionsWhoReceivedOldValue", reactionsToPrint)

                                let d = Reaction.beginDeferred()
                                _this.reactionsWhoReceivedOldValue.forEach(x => x.makeDirty())
                                d.end()
                            }

                            _this.reactionsWhoReceivedOldValue = undefined                            

                        }
                        
                            
                    }

                } catch (e) {


                    

                    console.error(e)
                }                
            }
        }



        return _this.value
    }


    /*_this.setValueKeepBinding = function (value) {

        if (_this.value === value)
            return
        _this.value = value
        var d = Reaction.beginDeferred()
        _this.makeDependentReactionsDirty()
        d.end()
        if (_this.binding) {
            _this.binding.dirty = false
        }
    }*/

    _this.setValue = function(value) {
        //console.log("setValue " + value + " " + _this.onChanged.size)
        if (typeof value === 'function') {

            if (value.isBindingConstructor) {
                value = value(_this)
            }

            if (_this.binding) {
                if (_this.binding.func === value) {
                    return
                }
                _this.binding.unsubscribeFromTriggeringProperties()
                //console.log("change binding from", _this.binding.func, "to", value)
            }
            
            _this.binding = new Binding(value, _this.onBindingBecameDirty)


        } else {
            //console.log("value assigned", _this.value, "->", value, "will notify ", _this.onChanged.size)
            if (_this.binding) {
                _this.binding.unsubscribeFromTriggeringProperties()
                _this.binding = undefined
            }

            if (_this.value === value)
                return

            _this.value = value
        }

        var d = Reaction.beginDeferred()
        _this.makeDependentReactionsDirty()
        d.end()
    }



    _this.attach = function(object, name) {
        //let property = this
        _this.name = name
        _this.object = object
        let accessorDescriptor = {
            get: function () {
                return _this.getValue()
            },
            set: function (value) {
                _this.setValue(value)

            }
        }
        Object.defineProperty(object, name, accessorDescriptor);
        return _this
    }    
    _this.setValue(value)
}



Property.exists = function (target, name) {
    var propertyDescriptor = !!Object.getOwnPropertyDescriptor(target, name)
    var propertyFieldExists = target.hasOwnProperty("__" + name)
    return propertyDescriptor && propertyFieldExists
}

Property.nameAvailable = function (target, name) {
    if (Object.getOwnPropertyDescriptor(target, name))
        return false
    if (target.hasOwnProperty(name))
        return false
    return true
}

Object.defineProperty(Object.prototype, "Reactive", {
    get: function () {
        return new Proxy(
            this,
            {
                get(target, name, receiver) {
                    //console.log(`get target:${JSON.stringify(target)} name: ${name}`)
                    return target["__" + name]
                    //return Reflect.get(...arguments);
                },
                set: function (target, name, value, receiver) {
                    //console.log("set",target,name,value)
                    
                    if (target.hasOwnProperty("__" + name)) {
                        //console.log("asigning existing property", name)
                        const propertyField = target["__" + name]
                        propertyField.setValue(value)
                    } else {
                        //console.log("creating new property", name)
                        target["__" + name] = new Property(value).attach(target,name)
                    }
                }
            }
            )
    },
    set: function (obj) {
        let proxy = this.Reactive
        //console.log(proxy)

        let d = Reaction.beginDeferred()
        //отложенное выполнение реакций не нужно при создании свойств
        //тут оно используется т.к. следующий код можнт не только создать свойство
        //но и присвоить значение существующему свойству
        if (obj instanceof Object) {
            for (const [key, value] of Object.entries(obj)) {
                proxy[key] = value                
            }
        }
        if (d) d.end()


    }
});


function OnChanged(getter, action) {
    let previous = undefined
    return new Reaction(() => {
        let current = getter()
        if (current != previous) {
            let n = Reaction.beginNonReactive()
            action(previous, current)
            n.end()
            previous = current
        }
    })
}




function OnTruthify(predicate, action) {
    
    let previous = undefined
    return new Reaction(() => {        
        let current = predicate()
        if (current === true && (!previous === true)) {
            let n = Reaction.beginNonReactive()
            action()            
            n.end()
        }
        previous = current
    })
}

function PropertyTest() {

    console.group("PropertyTest")

    let root = {
        Field: 7

    }

    console.assert( Property.nameAvailable(root, "A") == true)
    console.assert( Property.nameAvailable(root, "Field") == false)


    console.assert( Property.exists(root, "A") == false)

    root.Reactive.A = 0

    console.assert( Property.exists(root, "A") == true)
    console.assert( Property.nameAvailable(root, "A") == false)

    console.assert(root.A == 0)
    root.Reactive.A = 8
    console.assert(root.A == 8)


    root.Reactive.B = () => root.A * 2
    console.assert( root.B == 16)

    root.A = 10
    console.assert( root.B == 20)

    

    root.Reactive = {
        C: 7,
        D: () => root.C,
        //E: () => root.B*4,
    }

    console.assert( Property.exists(root, "C") == true)
    console.assert( Property.exists(root, "D") == true)

    console.assert(root.D == root.C)
    //console.assert(root.E == root.B*4)

    root.Reactive.B = () => root.A * 3
    //console.assert(root.B == 30)
    //console.assert(root.E == root.A * 3 * 4)

    /*root.Reactive.B = 10
    console.assert(root.E == 40)

    root.Reactive.B = () => root.A * 3
    console.assert(root.E == 10 * 3 * 4)*/


    new Reaction(() => {
        root.Field = root.C
    })
    console.assert(root.Field == root.C)

    let bReactionResult
    new Reaction(() => {
        bReactionResult = root.B
    })
    console.assert(bReactionResult == root.B)
    console.group("root.A = 20")
    root.A = 20
    console.groupEnd()
    console.assert(bReactionResult == root.B)


    root.C = 9
    console.assert(root.Field == root.C)
    console.assert(root.D == root.C)


    root.Reactive.D = ()=>root.C+1



    console.groupEnd()
}

Object.defineProperty(Object.prototype, "Events", {
    get: function () {

        const prefix = "___"

        return new Proxy(
            this,
            {
                get(target, name, receiver) {
                    return target[prefix + name]
                },
                set: function (target, name, value, receiver) {
                    name = name.toLowerCase()

                    function add(event) {
                        target[prefix + name] = event
                        target.addEventListener(name, event.handler, event)
                    }

                    if (target.hasOwnProperty(prefix + name)) {
                        let event = target[prefix + name]
                        if (event !== undefined)
                            target.removeEventListener(name, event.handler)
                    }

                    //console.log("set", target, name, typeof (value), value)

                    if (value !== undefined) {

                        if (typeof (value) === "function") {
                            add({
                                handler: value,
                                capture: false,
                            })
                        } else if (typeof (value) === "object") {
                            if (typeof (value.handler) !== "function") {
                                console.error("If the value is an object, it must have a 'handler' field of type 'function'")
                            }
                            value.capture = false
                            add(value)
                        } else {
                            console.warn(`Type '${typeof(value)}' is invalid for event. To remove event handler assign 'undefined'`)
                        }
                    }
                }
            }
        )
    }/*,
    set: function (obj) {
    }*/
});




/*function CreatePage() {
    let result = CreateInplace(document.body,Page)
    result.Content = function (parent) {
        let result = Create(ScrollLayout)
        result.Parent = parent
        result.Content = function (parent) {
            let result = Create(parent, Column)
            return result
        }(result)

        result.AddChild()

        return result
    }(result)

    Create(undefined, Page, (parent) => {
        parent.TopBar = Create(parent, Paragraph)
            .AddChild((parent) => {

            })

        parent.Content = function(parent){
            let result = Create(parent, ScrollLayout)
            result.Content = function (parent) {
                let result = Create(parent, Column)
                return result
            }(result)
        }()


        parent.Content = Create(parent, ScrollLayout).Modify((p) => {
            p.Content =
                Create(p, Column, (p) => {

                })
        })

        parent.AddChild(
            Create(parent, ScrollLayout, (parent) => {

            })
        )
    })
}*/









function GetParentElementByPredicate(firstParentToCompare, predicate) {
    var p = firstParentToCompare
    while (p != undefined) {
        if (predicate(p)) {
            
            return p
        } else {
            /*if (p.tagName == "SCROLLABLE") {
                console.error("SCROLLABLE", p.parentElement)
            }*/
            p = p.parentElement
        }
    }
    return undefined
}



function Hierarchical(element) {
    element.isHierarchical = true

    

    element.Reactive = {


        IsRoot: () => element.Parent == undefined,

        NestingDepth: () => (element.IsRoot || element.overlaySign==1) ? 0 : (element.Parent.NestingDepth + 1),

        Root: () => element.Parent.Root,
        /*Parent: undefined() => {

            let v = GetParentElementByPredicate(element.parentElement, x => x.isHierarchical)

            return v
        },*/
        ParentBlock: () => GetParentElementByPredicate(element.Parent, x => x.isBlock),
        FirstChild: undefined,
        LastChild: undefined,
        NextSibling: undefined,
    }

    if (element.Parent) {
        if (element.dataset.property) {
            element.Parent[element.dataset.property] = element

        }
        if (element.dataset.child!=undefined) {
            
            if (!element.Parent.FirstChild) {
                element.Parent.FirstChild = element
                element.Parent.LastChild = element
            } else {
                element.Parent.LastChild.NextSibling = element
                element.Parent.LastChild = element
            }
        }
        
    }

    



    element.Children = {}
    element.Children[Symbol.iterator] = function* () {
        var i = element.FirstChild
        while (i != undefined) {
            yield i
            i = i.NextSibling
        }
    };

    element.Sibling = function (id) {
        return element.Parent.Child(id)        
    }

    element.Child = function (id) {
        let i = element.FirstChild
        
        if (typeof id === "number") { 
            for (let i = 0; i < id; i++) {                
                i = i.NextSibling
                console.warn(i)
            }

        } else {
            while (i) {
                if (i.id == id) {
                    return i
                }
                i = i.NextSibling
            }
        }
        //console.warn(`element ${element.tagName} do not have child "${id}"`)
        return i
    }


    
 

}


function BaseModifier(element) {

    Hierarchical(element)

    element.isModifier = true

    element.Reactive = {
        Hover: false,
        Selectable: undefined,

        BackgroundColor: undefined,
        HierarchyBackgroundColor: () => element.BackgroundColor || element.Parent.HierarchyBackgroundColor,

        ForegroundColor: () => {   
            return element.HierarchyBackgroundColor.contrastColor()
        },
        HierarchyForegroundColor: () => element.ForegroundColor || element.Parent.HierarchyForegroundColor,


        FontSize: undefined,
        HierarchyFontSize: () => element.FontSize || element.Parent.HierarchyFontSize,

        Radius: undefined,
        RadiusTopLeft: () => element.Radius,
        RadiusTopRight: () => element.Radius,
        RadiusBottomLeft: () => element.Radius,
        RadiusBottomRight: () => element.Radius,

        Visibility: 1
    }

    new Reaction(() => {
        let visibility = element.Visibility
        if (visibility == 0) {
            element.style.visibility = "hidden"
            element.style.opacity = ""
        } else if (visibility == 1) {
            element.style.visibility = ""
            element.style.opacity = ""
        } else {
            element.style.opacity = visibility
            element.style.visibility = ""
        }        
    })


    new Reaction(() => {
        element.style.borderTopLeftRadius       = ToCssSize(element.RadiusTopLeft)
        element.style.borderTopRightRadius      = ToCssSize(element.RadiusTopRight)
        element.style.borderBottomLeftRadius    = ToCssSize(element.RadiusBottomLeft)
        element.style.borderBottomRightRadius   = ToCssSize(element.RadiusBottomRight)
    })



    new Reaction(() => {
        let selectable = element.Selectable
        if (selectable!=undefined)
            element.style.userSelect = element.Selectable ? "text" : "none"
        else
            element.style.userSelect = ""
    })
    

    new Reaction(() => {
        if (element.BackgroundColor) {
            element.style.backgroundColor = element.BackgroundColor
        }
    })

    new Reaction(() => {
        if (element.ForegroundColor) {
            element.style.color = element.ForegroundColor
        }
    })
}


/*function CalcLeft(container, child) {
    if (container.PaddingLeft != undefined) {
        return Math.max(container.PaddingLeft, First(child.MarginLeft,0))
    }
    if (container.MarginLeft == undefined) {
        return First(child.MarginLeft,0)
    }
    return Math.max(child.MarginLeft - container.MarginLeft, 0)
}*/

function CalcOffset(container, child, sideName) {
    let paddingName = "Padding" + sideName
    let marginName = "Margin" + sideName
    if (container[paddingName] != undefined) {
        return Math.max(container[paddingName], First(child[marginName], 0))
    }
    if (container[marginName] == undefined) {
        return First(child[marginName], 0)
    }
    if (child[marginName] == undefined) {
        return 0
    }
    return Math.max(child[marginName] - container[marginName], 0)
}


function Block(element) {
    

    BaseModifier(element)

    element.isBlock = true



    element.Reactive = {
        
        Depth: 0,

        PaddingLeft: undefined,
        PaddingTop: undefined,
        PaddingRight: undefined,
        PaddingBottom: undefined,

        MarginLeft: undefined,
        MarginTop: undefined,
        MarginRight: undefined,
        MarginBottom: undefined,

        LayoutX: undefined,
        LayoutY: undefined,
        LayoutWidth: undefined,
        LayoutHeight: undefined,

        

        InternalWidth: undefined,
        InternalHeight: undefined,


        X: () => First(element.LayoutX,0),
        Y: () => First(element.LayoutY,0),

        AbsoluteX: () => element.IsRoot ? 0 : Sum(element.Parent.AbsoluteX, element.Parent.ScrollXActual, element.X),
        AbsoluteY: () => element.IsRoot ? 0 : Sum(element.Parent.AbsoluteY, -element.Parent.ScrollYActual, element.Y),

        Width: () => First(element.LayoutWidth, element.InternalWidth),
        Height: () => First(element.LayoutHeight, element.InternalHeight),

        
        
    }

    DepthToStyle(element)


    XToStyle(element);
    YToStyle(element);
    WidthToStyle(element)
    HeightToStyle(element)

    

    



    new Reaction(() => {
        element.style.fontSize = ToCssSize(element.FontSize)
    })

    element.Events.MouseEnter = () => element.Hover = true
    element.Events.MouseLeave = () => element.Hover = false


    


}


function Page(element) {
    element.isRoot = true
    let loadingDeffered = Reaction.beginDeferred()

    Block(element)


    function getWindowWidth() {
        return document.documentElement.clientWidth //window.innerWidth
    }
    function getWindowHeight() {
        return window.innerHeight // document.documentElement.clientHeight
    }


    let animationFrame = 0
    window.Reactive = {
        Root: element,

        AnimationFrame: () => {
            animationFrame++
            window.requestAnimationFrame(() => {
                window.Reactive.AnimationFrame.makeDirty()
            });
            return animationFrame
        },

        UserInteracted: false,
        DevicePixelRatio: window.devicePixelRatio,
        Touch: false,
    }

    let touchMedia = window.matchMedia("(pointer: coarse)")
    window.Touch = touchMedia.matches
    touchMedia.onchange = (e) => {
        window.Touch = e.matches
    }

    function createDevicePixelRatioCallback(func) {
        let matchMedia = window.matchMedia(`screen and (resolution: ${window.devicePixelRatio}dppx)`)
        matchMedia.addEventListener(
            "change",
            () => {
                func()
                createDevicePixelRatioCallback(func)
            },
            { once: true }
        );
    }
    createDevicePixelRatioCallback(() => window.DevicePixelRatio = window.devicePixelRatio)



    element.Reactive = {
        Root: element,        

        LayoutWidth: getWindowWidth(),
        LayoutHeight: getWindowHeight(),

        FontSize: 16,
        HierarchyFontSize: () => element.FontSize,

        BackgroundColor: new Color("#fff"),

        HierarchyBackgroundColor: () => element.BackgroundColor,
        HierarchyForegroundColor: () => element.ForegroundColor,

    }



    /*window.ontouchend = () => {
        console.log("ontouchend")
        element.UserInteracted = true
    }*/
    window.onmousedown = () => {
        window.UserInteracted = true
    }




    window.onresize = function (event) {
        //let startTime = performance.now()
        let d = Reaction.beginDeferred()
        element.LayoutWidth = getWindowWidth()
        element.LayoutHeight = getWindowHeight()
        d.end()
        //console.log("resize", performance.now() - startTime)
    }


    
    let loadEventsToWait = 2
    function onLoadEvent() {
        loadEventsToWait--
        if (loadEventsToWait == 0) {

            console.log("-------------Reactions------------", performance.now());
            loadingDeffered.end()
            console.log("-------------Reactions-done-------", performance.now());
            

            document.body.style.visibility = "visible"
            document.body.style.opacity = 1

            if (location.hash !== "") {
                location.href = location.hash
            }



            /*let d = Reaction.beginDeferred()
            element.WindowWidth = getWindowWidth()
            element.WindowHeight = getWindowHeight()
            d.end()*/
        }
    }

    document.fonts.ready
        .then(() => {
            console.log("-------------Fonts ready--", performance.now());
            onLoadEvent()            
        })

    window.addEventListener("DOMContentLoaded", function (event) {
        console.log("------DOMContentLoaded--", performance.now());
        onLoadEvent()
    })



    

}




    /*var template = document.createElement('div');
    template.style.display = "contents"
    element.appendChild(template);
    new Reaction(() => {
        template.innerHTML = element.Html;

    })*/

    //element.insertAdjacentHTML('beforeend', `<svg width="800" viewBox="0 0 800 600" x="2 ${200}"><circle cx="500" cy="500" cx="500"r="20"></circle></svg>`);
    //console.log(`265 && element.ContentWidth`)



    /*element.Reactive =
    {
        A: () => {
            console.log("Get A")
            return Max(element.B, element.E)
        },

        //C: () => { Max(element.E, element.A) },

        E: () => {
            console.log("Get E")
            return element.A
        },

        B: 6
    }

    //let d = Reaction.beginDeferred()

    new Reaction(() => {
        console.group("Reaction A:")
        console.log("element.Reactive.E.binding.dirty:", element.Reactive.E.binding.dirty)
        console.log("element.Reactive.A.binding.dirty:", element.Reactive.A.binding.dirty)

        console.log("Reaction A:", element.A)

        console.groupEnd()
    })

    //d.end()

*/
    


    /*new Reaction(() => {
        console.log("Reaction E:", element.E)
    })

    console.log("element.Reactive.E.binding.dirty:", element.Reactive.E.binding.dirty)
    console.log("element.Reactive.A.binding.dirty:", element.Reactive.A.binding.dirty)*/

    




    //PropertyTest()

    

    

    /*let previous = this.Content
    let onChanged = function (previous, current) {
        if (current) {
            this.Content.InnerWidth =
                () => Math.min(this.Content.Width, parameters.ContentWidth)
        }
    }
    new Reaction(() => {
        let current = this.Content
        if (current != previous) {
            onChanged(previous, current)
            previous = current
        }
    })*/


    /*new Reaction(() => {

        if (this.Content)
            console.log("Content.PaddingLeft changed", this.Content.PaddingLeft)
    })*/



 

    //console.log(parameters.ContentWidth)


    /*new Property().attach(element, "Content")

    new Property(window.innerWidth).attach(window, "InnerWidth")
    new Property(window.innerHeight).attach(window, "InnerHeight")


    const LeftBarSize = 200
    const RightBarSize = 50

    new Reaction(() => {
        if (element.Content) {

            element.Content.style.left = LeftBarSize+"px"

            element.Content.MaxInnerWidth = parameters.ContentWidth
            element.Content.Width = window.InnerWidth - LeftBarSize - RightBarSize
        }
    })


    

    */


    /*element.css({
        margin: "0",
    })
    let leftBarWidth = 0;
    let rightBarWidth = 0;

    //contentWidth = 800;

    element.onAnchorsChanged = []
    element.anchors = {}
    var leftBar = element.querySelector("#leftBar");
    var rightBar = document.getElementById("#rightBar");

    leftBarWidth = leftBar == null ? 0 : leftBar.width;
    rightBarWidth = rightBar == null ? 0 : rightBar.width;

    function updateHeaderWidth() {
        let left = element.anchors.textLeft;
        let right = element.anchors.textRight;
        header.style.marginLeft = left + "px";
        header.style.width = right - left + "px";
    }



    function updateAnchors() {
        

        var leftBar = element.querySelector("#leftBar");
        var rightBar = element.querySelector("#rightBar");
        leftBarWidth = leftBar == null ? 0 : leftBar.offsetWidth;
        rightBarWidth = rightBar == null ? 0 : rightBar.offsetWidth;
        const textMargin = 12;
        let width = window.innerWidth;
        let wideAnchorsCollapsed = width < (leftBarWidth + rightBarWidth + contentWidth);
        element.anchors.wideLeft = wideAnchorsCollapsed ? 0 : leftBarWidth;
        element.anchors.wideRight = wideAnchorsCollapsed ? width : width - rightBarWidth;
        element.anchors.wideAnchorsCollapsed = wideAnchorsCollapsed;
        let fillAnchorsCollapsed = width < contentWidth;
        let center = 0.5 * (element.anchors.wideLeft + element.anchors.wideRight);
        element.anchors.fillLeft = fillAnchorsCollapsed ? 0 : (center - 0.5 * contentWidth);
        element.anchors.fillRight = fillAnchorsCollapsed ? width : (center + 0.5 * contentWidth);

        element.anchors.textLeft = Math.max(element.anchors.fillLeft, element.anchors.wideLeft + textMargin);
        element.anchors.textRight = Math.min(element.anchors.fillRight, element.anchors.wideRight - textMargin);

        element.onAnchorsChanged.map(x => x());
        if (wideAnchorsCollapsed) {
            document.getElementById("rightBar").style.visibility = "hidden";
            document.getElementById("leftBar").style.visibility = "hidden";
        } else {
            document.getElementById("rightBar").style.visibility = "";
            document.getElementById("leftBar").style.visibility = "";
        }

    }

    DetectSwipe(element, swiper);

    function swiper(direction, swipe, touchEnd, event) {
        let getTranslate = (offsetWidth) => {
            var value = direction == 'left' || direction == 'right' ? swipe.swipeX : swipe.swipeY;
            let percent = toPercents(Math.abs(value), offsetWidth);
            let translate = percent > 0 ? percent : 0;
            return translate;
        }

        let showChildren = (element) => Array.from(element.children).forEach(x => {
            x.css({ visibility: "visible" });
        });

        if (direction == 'left') {
            let allSwiped = event.path.map(x => x.scrollLeft == null ? true : x.scrollLeft === x.scrollWidth - x.clientWidth).every(x => x == true);
            if (allSwiped) {
                let startY = swipe.clientStartY;
                let touchedElementSpace = menusHitBoxes.find(x => x.top <= startY && x.bottom >= startY);
                if (touchedElementSpace == null) { return; }
                let selectedMenu = touchedElementSpace.element
                if (selectedMenu.position == 'minimizedRight') {
                    showChildren(selectedMenu);
                    let translate = 100 - getTranslate(selectedMenu.offsetWidth);
                    selectedMenu.css({ transform: `translateX(clamp(0%, ${translate}%, 70%))` });
                }
            }
        } else {
            //menusHitBoxes.forEach(x => x.element.css({ transform: 'translateX(70%)' }));
        }
    }

    menusHitBoxes = [];


    window.addEventListener("resize", updateAnchors);
    document.addEventListener("DOMContentLoaded", function() {

        element.style.display = "";
        rightBarWidth = document.getElementById("rightBar").scrollWidth;
        leftBarWidth = document.getElementById("leftBar").scrollWidth;
        header = document.getElementById("Header");
        if (header != null) {
            element.onAnchorsChanged.push(updateHeaderWidth);
        }
        updateAnchors()
        var rightBar = document.getElementById('rightBar');
        var children = Array.from(rightBar.children)
        children.forEach(x => {
            var rect = x.getBoundingClientRect();
            let element = {
                element: x,
                top: rect.top,
                bottom: rect.bottom
            }
            menusHitBoxes.push(element);
        });
    });*/


function Color() {
    let args = [...arguments]
    let _this = this

    _this.r = 0
    _this.g = 0
    _this.b = 0
    _this.a = 1

    if (args.length == 0) {
        return
    }

    if (args.length == 1) {
        let input = args[0]
        if (typeof input == 'number') {
            _this.r = (input & 0xFF) / 255
            _this.g = ((input & 0xFF00) >>> 8) / 255
            _this.b = ((input & 0xFF0000) >>> 16) / 255
            _this.a = ((input & 0xFF000000) >>> 24) / 255
            return;
        }

        if (typeof input == 'string') {
            
            if (input.substr(0, 1) == "#") {
                var collen = (input.length - 1) / 3;
                var fact = [17, 1, 0.062272][collen - 1] / 255;
                _this.r = parseInt(input.substr(1, collen), 16) * fact
                _this.g = parseInt(input.substr(1 + collen, collen), 16) * fact
                _this.b = parseInt(input.substr(1 + 2 * collen, collen), 16) * fact 
                return
            }

            //} return input.split("(")[1].split(")")[0].split(",").map(x => +x)

        }

        console.warn("Color: Invalid arguments", input)
    }

    if (args.some(x => (typeof x) != 'number')) {
        console.warn("Color: Invalid arguments types", args)
        return;
    }

    if ((args.length >= 3) & (args.length <= 4)) {
        _this.r = args[0]
        _this.g = args[1]
        _this.b = args[2]

        if (args.length == 4) {
            _this.a = args[3]
        }
        return
    }
    
    console.warn("Color: Invalid arguments", args)

}

Color.prototype.toString = function () {
    return `rgba(${Math.round(255 * this.r)},${Math.round(255 * this.g)},${Math.round(255 * this.b)},${this.a})`
}

Color.prototype.lerp = function (targetColor, amount) {
    var bk = (1 - amount);
    var a = this.a * bk + targetColor.a * amount;
    var r = this.r * bk + targetColor.r * amount;
    var g = this.g * bk + targetColor.g * amount;
    var b = this.b * bk + targetColor.b * amount;
    return new Color(r, g, b, a);
}

Color.prototype.contrastColor = function (contrast = 1) {
    var grayscale = (0.2125 * this.r) + (0.7154 * this.g) + (0.0721 * this.b);
    var blackOrWhite = (grayscale > 0.5) ? new Color(0, 0, 0, 1) : new Color(1, 1, 1, 1);
    return this.lerp(blackOrWhite, contrast);
}
var glass = undefined

function getGlass() {
    if (!glass) {
        glass = document.createElement("glass")
        document.body.appendChild(glass)
        Glass(glass)
    }
    return glass
}

const glassZIndex = 99
function Glass(element) {
    element.style.width = "100vw"
    element.style.height = "100vh"
    //element.style.backgroundColor = "black"
    element.style.zIndex = glassZIndex
    element.style.position = "fixed"


    element.Reactive = {
        Color: new Color(0xff000000),
        Visibility: 1,
        MaxOpacity: 0.7
    }
    new Reaction(() => {
        element.style.backgroundColor = element.Color
    })

    new Reaction(() => {
        //element.style.backdropFilter = `blur(${element.Visibility*10}px)`;
        element.style.opacity = element.Visibility * element.MaxOpacity
        element.style.display = element.Visibility == 0 ? "none" : "block"
    })
}

function lerp(a, b, t) {
    return a + t * (b - a)
}

function AnimateTo(targetValue, duration) {
    
    let result = (property) => {
        
        let startValue = property.value
        let startTime = performance.now()

        return () => {
            let elapsed = performance.now() - startTime
            
            if (elapsed < duration) {
                window.AnimationFrame
            }
            let t = (typeof targetValue === "function") ? targetValue() : targetValue
            let mormalizedTime = Math.min(elapsed / duration, 1)
            
            return lerp(startValue, t, mormalizedTime)
        }
    }
    result.isBindingConstructor = true
    return result
}




function PageSideMenus(element) {
    Page(element)


 
    let glass = getGlass()

    const minSwipeToOpen = 40
    const minSwipeToClose = 20
    const swipeThreshold = 10

    let toggle = false
    element.Events.Click = () => {
        
        /*toggle = !toggle
        element.ContentWidth = AnimateTo(
            () => toggle ? (element.WindowWidth - 100) : 500,
            10000)*/
    }

    element.Reactive = {
        ContentWidth: 960,
        SideBarsIconsSize: 48,

        BarsCollapsed: () =>
            element.Width < Sum(
                element.ContentWidth,
                element.LeftSideBar ? element.LeftSideBar.Width : 0,
                element.RightSideBar ? element.RightSideBar.Width : 0),

        //Content: () => element.Child("Content"),

        SideBarOpen: 0, //-1 left , 1 right

        //LeftSideBar: () => element.LeftSideBar,
        //LeftSideBarIcon: () => element.LeftSideBarIcon,

        //RightSideBar: () => element.RightSideBar,
        //RightSideBarIcon: () => element.RightSideBarIcon,

        TopBar: () => element.Content.Content.TopBar,

        Footer: undefined,

        SwipeXAboveThreshold: () => {
            if (element.SwipeX > swipeThreshold)
                return element.SwipeX - swipeThreshold
            if (element.SwipeX < -swipeThreshold)
                return element.SwipeX + swipeThreshold
            return 0
        },


        MinSwipeToOpen_LeftSideBar: () => element.LeftSideBar ? Min(minSwipeToOpen, element.LeftSideBar.Width) : undefined,
        MinSwipeToOpen_RightSideBar: () => element.RightSideBar ? Min(minSwipeToOpen, element.RightSideBar.Width) : undefined,

        SwipeX: 0,
        SwipeY: 0,
        Swipe: false,

        LeftSideBarSwipeProgress : 0,
        RightSideBarSwipeProgress: 0,

    }




    let startX = 0
    let startY = 0

    const iconMargin = 10
    const collapsedIconWidth = 6
    const collapsedIconHeight = 120
    

    function touchStart() {
        var touch = event.touches[0];
        startX = touch.clientX;
        startY = touch.clientY;
        
    }
    function horizontalTouchMove() {
        if (!event.cancelable) return
        var touch = event.touches[0];
        //console.log("horizontalTouchMove", event.path)
        let d = Reaction.beginDeferred()
        element.SwipeX = touch.clientX - startX
        element.SwipeY = touch.clientY - startY
        element.Swipe = true
        d.end()
        event.preventDefault()
    }


    element.pan = function (x, y) {
        console.log("pan",element.tagName,x,y)
        return [x,y]
    }

    
    document.Events.TouchStart = {
        handler: () => {
            //if (event.pointerType != "touch") return

            //console.log("document TouchStart", event.path)
            touchStart()
            document.Events.TouchMove = () => {
                //console.log("document PointerMove", event.path, event.clientX, event.cancelable)
                if (event.cancelable) {
                    var touch = event.touches[0];
                    let deltaX = Math.abs(touch.clientX - startX)
                    //console.log("deltaX", deltaX, swipeThreshold)
                    if (deltaX > swipeThreshold) {
                        event.preventDefault()
                        //console.log("horizontalTouchMove...")
                        element.Events.TouchMove = {
                            handler: horizontalTouchMove,
                            passive: false
                        }
                    }
                } else {
                    //console.log("PointerMove = undefined")
                    document.Events.TouchMove = undefined
                    document.Events.TouchEnd = undefined
                }
            }
            element.Events.TouchEnd = () => {
                //console.log("TouchEnd")
                element.Swipe = false
                element.Events.TouchMove = undefined
                element.Events.TouchEnd = undefined
            }
        },
        passive: false
    }
    

    glass.Events.TouchStart = {
        handler: () => {
            touchStart()

            glass.Events.TouchMove = {
                handler: horizontalTouchMove,
                passive: false
            }

            glass.Events.TouchEnd = () => {
                element.Swipe = false
                glass.Events.TouchMove = undefined
                glass.Events.TouchEnd = undefined
            }
        },
        passive: false
    }

    glass.Events.Click = () => {
        element.SideBarOpen = 0
    }

    


    new Reaction(() => {
        if (element.TopBar) {
            if (element.LeftSideBar && element.BarsCollapsed) {
                element.TopBar.MarginLeft = element.SideBarsIconsSize + iconMargin
            } else {
                element.TopBar.MarginLeft = 0
            }
        }
    })
    new Reaction(() => {
        if (element.TopBar) {
            if (element.RightSideBar && element.BarsCollapsed) {
                element.TopBar.MarginRight = element.SideBarsIconsSize + iconMargin
            } else {
                element.TopBar.MarginRight = 0
            }
        }
    })
    new Reaction(() => {
        if (element.TopBar) {
            if ((element.RightSideBar || element.LeftSideBar) && element.BarsCollapsed) {
                element.TopBar.Height = () => Max(element.TopBar.InternalHeight, element.SideBarsIconsSize)
            } else {
                element.TopBar.Height = () => First(element.TopBar.InternalHeight, element.SideBarsIconsSize)
            }
        }
    })




    


    new Reaction(() => {
        if (element.LeftSideBar) {
            element.LeftSideBar.Depth = glassZIndex + 1
            //element.LeftSideBar.style.position = "fixed"
            element.LeftSideBar.Height = () => element.Height
        }
    })

    new Reaction(() => {
        if (element.RightSideBar) {
            element.RightSideBar.Depth = glassZIndex + 1
            //element.RightSideBar.style.position = "fixed"
            element.RightSideBar.Height = () => element.Height
        }
    })




    OnTruthify(
        () => !element.Swipe,
        () => {
            if (element.BarsCollapsed) {
                if (element.SideBarOpen == 0) {
                    if (element.LeftSideBar && element.SwipeXAboveThreshold > element.MinSwipeToOpen_LeftSideBar) {
                        element.SideBarOpen = -1
                        return
                    }
                    if (element.RightSideBar && element.SwipeXAboveThreshold < -element.MinSwipeToOpen_RightSideBar) {
                        element.SideBarOpen = 1
                        return
                    }
                } else {
                    if (Math.sign(element.SwipeXAboveThreshold) == Math.sign(element.SideBarOpen) && Math.abs(element.SwipeXAboveThreshold) > minSwipeToClose) {
                        element.SideBarOpen = 0
                    }
                }
            }
        }
    )

    new Reaction(() => {
        if (!element.BarsCollapsed) {
            element.SideBarOpen = 0
        }
    })

    //Glass Visibility
    new Reaction(() => {
        if (!element.BarsCollapsed) {
            glass.Visibility = 0
        } else {
            if (element.SideBarOpen == 0) {
                if (element.Swipe) {
                    if (element.SwipeXAboveThreshold > 0) {
                        if (element.LeftSideBar) {
                            glass.Visibility = Math.min(Math.max(element.SwipeXAboveThreshold / element.MinSwipeToOpen_LeftSideBar, 0), 1)
                            return
                        }
                    }
                    if (element.SwipeXAboveThreshold < 0) {
                        if (element.RightSideBar) {
                            glass.Visibility = Math.min(Math.max(-element.SwipeXAboveThreshold / element.MinSwipeToOpen_RightSideBar, 0), 1)
                            return
                        }
                    }
                }
            } else {
                if (element.Swipe) {
                    glass.Visibility = Math.min(Math.max(1 - element.SwipeXAboveThreshold * element.SideBarOpen / minSwipeToClose, 0), 1)
                    return
                } else {
                    glass.Visibility = 1
                    return
                }
            }
        }
        glass.Visibility = 0

    })


    new Reaction(() => {
        if (element.LeftSideBar) {
            if (element.BarsCollapsed) {
                if (element.SideBarOpen == 0) {
                    if (element.Swipe) {
                        element.LeftSideBar.X = -element.LeftSideBar.Width + Clamp(element.SwipeXAboveThreshold, 0, element.LeftSideBar.Width)
                    } else {
                        element.LeftSideBar.X = -element.LeftSideBar.Width
                    }
                } else if (element.SideBarOpen == -1) {
                    if (element.Swipe) {
                        element.LeftSideBar.X = Clamp(element.SwipeXAboveThreshold, -element.LeftSideBar.Width, 0)

                    } else {
                        element.LeftSideBar.X = 0
                    }
                }
            } else {
                element.LeftSideBar.X = 0
            }
        }
    })

    new Reaction(() => {
        
        if (element.RightSideBar) {
            if (element.BarsCollapsed) {
                if (element.SideBarOpen == 0) {
                    if (element.Swipe) {
                        element.RightSideBar.X = element.Width + Clamp(element.SwipeXAboveThreshold, -element.RightSideBar.Width, 0)
                    } else {
                        element.RightSideBar.X = element.Width
                    }
                } else if (element.SideBarOpen == 1) {
                    if (element.Swipe) {
                        element.RightSideBar.X = element.Width - element.RightSideBar.Width + Clamp(element.SwipeXAboveThreshold, 0, element.RightSideBar.Width)
                    } else {
                        element.RightSideBar.X = element.Width - element.RightSideBar.Width
                    }
                } else if (element.SideBarOpen == -1) {
                    element.RightSideBar.X = element.Width 
                }
            } else {
                element.RightSideBar.X = element.Width - element.RightSideBar.Width
            }
        }
    })


    new Reaction(() => {

        let LeftBarSize = (element.LeftSideBar && !element.BarsCollapsed) ? Max(element.LeftSideBar.Width, 0) : 0

        let RightBarSize = (element.RightSideBar && !element.BarsCollapsed) ? Max(element.RightSideBar.Width, 0) : 0

        let width = element.Width - LeftBarSize - RightBarSize
        let innerWidth = Math.min(width, element.ContentWidth)
        let contentSpace = (width - innerWidth) * 0.5

        if (element.Content) {
            //element.Content.Height = element.WindowHeight
            element.Content.LayoutWidth = width// - 2 * contentSpace


            element.Content.Content.PaddingLeft = contentSpace
            element.Content.Content.PaddingRight = contentSpace
            element.Content.Content.Width = width

            element.Content.LayoutX = LeftBarSize
            element.Content.LayoutHeight = element.Height//(element.Content.InternalHeight, element.Height)
        }
    })




    function ConfugureIcon(icon) {
        icon.Reactive = {
            AnimationProgress: 1,
            AnimationTarget: () => element.Content.ScrollYActual > 0 || icon.BarVisible ? 0 : 1
        }

        OnChanged(
            () => icon.AnimationTarget,
            (p, c) => {
                icon.AnimationProgress = AnimateTo(c ? 1 : 0, 200)
            }
        )

        icon.Y = () => icon.MarginTop
        
        icon.Width = () => lerp(collapsedIconWidth, element.SideBarsIconsSize, icon.AnimationProgress)
        icon.Height = () => lerp(collapsedIconHeight, element.SideBarsIconsSize, icon.AnimationProgress)

        icon.Radius = () => lerp(icon.Width, 0.5 * icon.Width, icon.AnimationProgress)
        icon.Visibility = () => (element.BarsCollapsed) ? 1 : 0
        icon.Depth = () => icon.BarVisible ? glassZIndex + 1 : glassZIndex - 1 

    }

    OnChanged(
        () => element.LeftSideBar && element.LeftSideBarIcon,
        (p, c) => {
            if (c) {
                let icon = element.LeftSideBarIcon
                ConfugureIcon(icon)
                icon.Reactive.BarVisible = () => (element.LeftSideBar.Width + element.LeftSideBar.X) > 0                
                
                icon.X = () => icon.MarginLeft * icon.AnimationProgress + element.LeftSideBar.X + element.LeftSideBar.Width

                icon.RadiusTopLeft = () => 0.5 * icon.Width * icon.AnimationProgress
                icon.RadiusBottomLeft = () => 0.5 * icon.Width * icon.AnimationProgress

                icon.Events.Click = () => element.SideBarOpen = -1
            }
        }
    )

    OnChanged(
        () => element.RightSideBar && element.RightSideBarIcon,
        (p, c) => {
            if (c) {
                let icon = element.RightSideBarIcon
                ConfugureIcon(icon)
                icon.Reactive.BarVisible = () => element.RightSideBar.X < element.Width

                icon.X = () => element.RightSideBar.X - icon.MarginRight * icon.AnimationProgress - element.RightSideBarIcon.Width

                icon.RadiusTopRight = () => 0.5 * icon.Width * icon.AnimationProgress
                icon.RadiusBottomRight = () => 0.5 * icon.Width * icon.AnimationProgress

                icon.Events.Click = () => element.SideBarOpen = 1
            }
        }
    )


}
function MaterialDesignIcon(element) {
    /*new Reaction(() => {
        //element.style.fill = element.ForegroundColor
    })*/

    new Reaction(() => {
        let content = element.children[0]
        content.style.fill = element.HierarchyForegroundColor
    })
}


function MaterialDesignIconBlock(element) {
    Block(element)
    MaterialDesignIcon(element)


    let width = Number(element.dataset.width)
    let height = Number(element.dataset.height)


    element.Reactive = {

        Aspect: width / height,

        VerticalPaddingSum: () => Sum(element.PaddingTop, element.PaddingBottom, 0),
        HorizontalPaddingSum: () => Sum(element.PaddingLeft, element.PaddingRight, 0),

        InternalWidth: () => First((element.Height - element.VerticalPaddingSum) * element.Aspect + element.HorizontalPaddingSum, Sum(width, element.HorizontalPaddingSum)),
        InternalHeight: () => First((element.Width - element.HorizontalPaddingSum) / element.Aspect + element.VerticalPaddingSum, Sum(height, element.VerticalPaddingSum)),
    }


    new Reaction(() => {
        let content = element.children[0]
        let w = element.Width - element.HorizontalPaddingSum
        let h = element.Height - element.VerticalPaddingSum
        if (w <= 0 || h <= 0) {
            content.style.display = "none"
            content.style.width = ""
            content.style.height = ""
        } else {
            content.style.display = ""
            content.style.left = ToCssSize(element.PaddingLeft)
            content.style.top = ToCssSize(element.PaddingTop)
            content.style.width = ToCssSize(w)
            content.style.height = ToCssSize(h)
        }
    })

    


    
}


function Thumb(element) {
    Block(element)
    element.Reactive = {
        BackgroundColor: () => element.Parent.HierarchyForegroundColor,
        
        Radius: () => Min(element.Width, element.Height) / 2,
        Depth: 1,
        Visibility: () => (window.Touch || element.ThumbSizeScale >= 1) ? 0 : element.Hover ? 0.5 : 0.25,
    }
}

function SetupPointerDrag(element, func) {
    element.Events.PointerDown = () => {
        event.stopPropagation()
        event.preventDefault()
        element.setPointerCapture(event.pointerId)

        element.Events.PointerMove = () => {
            let x = event.movementX
            let y = event.movementY
            if (x != 0 || y != 0) {
                func(x,y)
            }            
        }
        element.Events.PointerUp = () => {
            element.Events.PointerUp = undefined
            element.Events.PointerMove = undefined
        }
        return false
    }
}



function ScrollLayout(element) {
    Block(element)

    


    element.Reactive = {
        InternalWidth: () => element.Content.InternalWidth,
        InternalHeight: () => element.Content.InternalHeight,
        //Content: () => element.Child("Content"),

        MarginLeft: () => (element.PaddingLeft!=undefined) ? 0 : element.Content.MarginLeft,
        MarginTop: () => (element.PaddingTop != undefined) ? 0 : element.Content.MarginTop,
        MarginRight: () => (element.PaddingRight != undefined) ? 0 : element.Content.MarginRight,
        MarginBottom: () => (element.PaddingBottom != undefined) ? 0 : element.Content.MarginBottom,

        LeftOffset: () => CalcOffset(element, element.Content, "Left"),
        RightOffset: () => CalcOffset(element, element.Content, "Right"),
        TopOffset: () => CalcOffset(element, element.Content, "Top"),
        BottomOffset: () => CalcOffset(element, element.Content, "Bottom"),

        ContentAreaWidth: () => element.Width - element.LeftOffset - element.RightOffset,
        ContentAreaHeight: () => element.Height - element.TopOffset - element.BottomOffset,

        ScrollX: undefined,
        ScrollY: undefined,

        ScrollXActual: 0,
        ScrollYActual: 0,

        ScrollBarThickness: 4,
        ScrollBarMargin: 2,

        ShowScrollBars: !window.Touch
    }

    

    let verticalThumb = Create(element, Thumb)
    verticalThumb.Reactive = {
        ThumbTravel: () => element.Height - 2 * element.ScrollBarMargin,
        ThumbPositionScale: () => verticalThumb.ThumbTravel / element.Content.InternalHeight,
        ThumbSizeScale: () => element.ContentAreaHeight / element.Content.InternalHeight, 
        X: () => element.Width - verticalThumb.Width - element.ScrollBarMargin,
        Y: () => element.ScrollBarMargin + element.ScrollYActual * verticalThumb.ThumbPositionScale,
        Width: () => element.ScrollBarThickness,        
        Height: () => verticalThumb.ThumbTravel * verticalThumb.ThumbSizeScale,
    }
    

    let horizontalThumb = Create(element, Thumb)
    horizontalThumb.Reactive = {
        ThumbTravel: () => element.Width - 2 * element.ScrollBarMargin,
        ThumbPositionScale: () => horizontalThumb.ThumbTravel / element.Content.Width,
        ThumbSizeScale: () => element.ContentAreaWidth / element.Content.Width,        
        X: () => element.ScrollBarMargin + element.ScrollXActual * horizontalThumb.ThumbPositionScale,
        Y: () => element.Height - horizontalThumb.Height - element.ScrollBarMargin,
        Width: () => horizontalThumb.ThumbTravel * horizontalThumb.ThumbSizeScale,
        Height: () => element.ScrollBarThickness,        
    }

    SetupPointerDrag(verticalThumb, (x, y) => {
        scrollable.scrollTop += y / verticalThumb.ThumbPositionScale
    })

    SetupPointerDrag(horizontalThumb, (x, y) => {
        scrollable.scrollLeft += x / horizontalThumb.ThumbPositionScale
    })


    let scrollable = document.createElement("scrollable")
    element.appendChild(scrollable)

    scrollable.style.touchAction = "manipulation"
    scrollable.style.overflow = "auto"
    //scrollable.style.outline = "0.1px solid #f00"
    
    new Reaction(() => {
        scrollable.style.left = ToCssSize(element.LeftOffset)
        scrollable.style.top = ToCssSize(element.TopOffset)
        scrollable.style.width = ToCssSize(element.ContentAreaWidth)
        scrollable.style.height = ToCssSize(element.ContentAreaHeight)
    })



    scrollable.Events.Scroll = () => {
        let d = Reaction.beginDeferred()
        element.ScrollXActual = scrollable.scrollLeft
        element.ScrollYActual = scrollable.scrollTop
        d.end()
    }


    new Reaction(() => {
        scrollable.appendChild(element.Content)
        element.Content.LayoutWidth = () => Max(element.Content.InternalWidth, element.ContentAreaWidth)
        element.Content.LayoutHeight = () => Max(element.Content.InternalHeight, element.ContentAreaHeight)
    })


   /*OnChanged(
        () => element.Content,
        (p, c) => {
            if (c) {                
                
            }
        }
    )*/


}
function Column(element) {
    Block(element)

    element.Reactive = {
        InternalWidth: () => {

            let internalWidth = undefined
            for (let child of element.Children) {
                let left = CalcOffset(element, child, "Left")
                let right = CalcOffset(element, child, "Right")

                //let spaceLeft = Max(element.PaddingLeft, child.MarginLeft, 0)
                //let spaceRight = Max(element.PaddingRight, child.MarginRight, 0)

                let internalWidthByCurrentChild = Sum(child.InternalWidth, left + right)

                internalWidth = Max(internalWidth, internalWidthByCurrentChild)
            }
            //console.log("internalWidth", internalWidth)
            return internalWidth
        },

        //InternalHeight: undefined,
        //Height: () => element.InternalHeight,
    }


    new Reaction(() => {
        for (let child of element.Children) {
            if (child.isBlock) {

                child.LayoutX = () => CalcOffset(element, child, "Left")               

                child.LayoutWidth = () => {
                    let left = CalcOffset(element, child, "Left")
                    let right = CalcOffset(element, child, "Right")
                    return element.Width - left - right
                }
            }
        }
    })

    new Reaction(() => {
        let previousMargin
        let freeSpaceUnits
        let freeSpacePixels
        let contentHeight

        function addElement(child, assignDimensions) {
            if (child.isSpace) {
                if (assignDimensions) {
                    contentHeight += freeSpacePixels / freeSpaceUnits * child.Between
                } else {
                    freeSpaceUnits += child.Between
                }
                return true;
            }

            if (child.isBlock) {
                /*if (!child.Height) {
                    console.log("Column !child.Height", child)
                    return false

                }*/

                //console.log("child.Height", Max(child.Height, 0), child)


                let margin = Max(child.MarginTop, previousMargin)
                previousMargin = child.MarginBottom || 0


                contentHeight += margin
                if (assignDimensions) {
                    child.LayoutY = contentHeight
                }
                contentHeight += Max(child.Height, 0)


                return true
            }
            return true
        }



        previousMargin = element.PaddingTop || 0
        freeSpaceUnits = 0
        contentHeight = 0

        for (let i of element.Children) {
            if (!addElement(i, false)) {
                return
            }
        }

        //console.log("ColumnAfter Reaction", element, element.LayoutChildren)

        //Here "previousMargin" contains last-child.MarginBottom
        contentHeight += Max(previousMargin, element.PaddingBottom)
        //console.log("Vertical layout", element, contentHeight)

        previousMargin = element.PaddingTop || 0
        element.InternalHeight = contentHeight;
        if (!element.Height)
            return

        freeSpacePixels = element.Height - contentHeight;// Math.max( element.Height - contentHeight, 0)

        if (freeSpacePixels < 0) {//overflow-y: overlay;
            element.style.overflowY = "auto"
            freeSpacePixels = 0
            if (!element.innerSizeHolder) {
                element.innerSizeHolder = document.createElement('holder')
                element.innerSizeHolder.style.position = "absolute"
                element.appendChild(element.innerSizeHolder)
                element.innerSizeHolder.style.width = "1px"
            }
            element.innerSizeHolder.style.height = contentHeight + "px"
        } else {
            element.style.overflowY = ""
            if (element.innerSizeHolder) {
                element.removeChild(element.innerSizeHolder)
                element.innerSizeHolder = undefined
            }
        }

        //console.log("freeSpacePixels", freeSpacePixels)

        contentHeight = 0

        for (let i of element.Children) {
            if (!addElement(i, true)) {
                return
            }
        }
    })


}

function Paragraph(element) {

    Block(element)


    element.Reactive = {
        Selectable: true,
        InternalWidth: () => Sum(element.MaxContentWidth,element.PaddingLeft, element.PaddingRight),

        InternalHeight: undefined,

        MaxContentWidth: undefined,
        MinContentWidth: undefined,

        MaxContentHeight: undefined,
        MinContentHeight: undefined,

        PaddingLeft: () => (element.BackgroundColor != undefined) ? 10 : undefined,
        PaddingRight: () => (element.BackgroundColor != undefined) ? 10 : undefined,
        PaddingTop: () => (element.BackgroundColor != undefined) ? 8 : undefined,
        PaddingBottom: () => (element.BackgroundColor != undefined) ? 8 : undefined,

        MarginLeft: () => (element.BackgroundColor != undefined) ? 0 : 10,
        MarginRight: () => (element.BackgroundColor != undefined) ? 0 : 10,
        MarginTop: () => (element.BackgroundColor != undefined) ? 0 : 8,
        MarginBottom: () => (element.BackgroundColor != undefined) ? 0 : 8,

    }

    /*new Reaction(() => {
        console.log(element, element.Child(0))
    })*/


    /*new Reaction(() => {
        let l = element.PaddingLeft
        let r = element.PaddingRight
        let w = element.Width
        if (l + r > w) {
            let m = w / (l + r)
            l *= m
            r *= m
        }
        element.style.paddingLeft = ToCssSize(l)
        element.style.paddingRight = ToCssSize(r)
    })

    new Reaction(() => {
        element.style.paddingTop = ToCssSize(element.PaddingTop)
    })
    new Reaction(() => {
        element.style.paddingBottom = ToCssSize(element.PaddingBottom)
    })*/


    new Reaction(() => {

        const testFontSize = 128;

        let content = element.children[0]

        //content.style.position = "initial"
        content.style.fontSize = testFontSize + "px";
        content.style.width = "min-content"
        var minWidthRect = content.getBoundingClientRect()
        content.style.width = "max-content"
        var maxWidthRect = content.getBoundingClientRect()

        content.style.fontSize = ""
        content.style.width = ""


        element.MaxContentWidth = () =>  element.HierarchyFontSize / testFontSize * maxWidthRect.width
        element.MinContentWidth = () =>  element.HierarchyFontSize / testFontSize * minWidthRect.width
        element.MaxContentHeight = () => element.HierarchyFontSize / testFontSize * minWidthRect.height
        element.MinContentHeight = () => element.HierarchyFontSize / testFontSize * maxWidthRect.height

    })

    new Reaction(() => {
        let content = element.children[0]
        /*
        Left,
        Center,
        Right,
        Justify,
        JustifyIncludingLastLine
         */
        

        if (element.TextAlignmentHorizontal == "JustifyIncludingLastLine") {
            content.style.textAlign = "justify"
            content.style.textAlignLast = "justify"
        } else {
            content.style.textAlignLast = ""
            if (element.TextAlignmentHorizontal === undefined) {
                content.style.textAlign = ""
            } else {
                content.style.textAlign = element.TextAlignmentHorizontal.toLowerCase()
            }
        }
    })


    new Reaction(() => {
        //console.log("element.HierarchyFontSize", element.HierarchyFontSize, element)
        //console.log("element.Modifier", element, element.Modifier)
        //console.log("element.Modifier.HierarchyFontSize", element, element.Modifier.HierarchyFontSize)
        element.style.width = ToCssSize(element.Width)

        let content = element.children[0]

        content.style.transformOrigin = ""
        content.style.transform = ""
        content.style.width = ""
        content.style.display = ""
        content.style.left = ToCssSize(element.PaddingLeft)
        content.style.top = ToCssSize(element.PaddingTop)

        let minContentWidthWithPaddings = Sum(element.MinContentWidth, element.PaddingLeft, element.PaddingRight)

        if (minContentWidthWithPaddings > element.Width) {
            //element.title = "element.MinContentWidth > element.Width"

            

            let scale = Sum(element.Width, -element.PaddingLeft, -element.PaddingRight) / element.MinContentWidth

            if (scale > 0) {
                content.style.width = "min-content"
                content.style.transformOrigin = "top left"
                content.style.transform = `scale(${scale}, ${scale})`
                element.InternalHeight = Sum(element.MaxContentHeight * scale, element.PaddingTop, element.PaddingBottom)
            } else {
                content.style.display = "none"
                element.InternalHeight = Sum(element.PaddingTop, element.PaddingBottom)
            }

            
            return
        }

        let maxContentWidthWithPaddings = Sum(element.MaxContentWidth, element.PaddingLeft, element.PaddingRight)
        if (Math.abs(element.Width - maxContentWidthWithPaddings) < 0.001) {
            //element.title = "element.Width == element.MaxContentWidth"

            element.InternalHeight = Sum(element.MinContentHeight, element.PaddingTop, element.PaddingBottom) 
            content.style.width = "max-content"

            return
        }
        

        content.style.width = ToCssSize(Sum(element.Width, -element.PaddingLeft, -element.PaddingRight))

        var rect = content.getBoundingClientRect()
        element.InternalHeight = Sum(rect.height, element.PaddingTop, element.PaddingBottom)

    })

    HeightToStyle(element)
}

function Link(element) {
    element.Reactive = {
        HRef: undefined,
        NewTab: false
    }

    new Reaction(() => {
        element.setAttribute("href", element.HRef)
    })
    new Reaction(() => {
        element.NewTab
            ? element.setAttribute("target", "_blank")
            : element.removeAttribute("target")
        
    })

}
function LinkBlock(element) {
    Block(element)
}
function Space(element) {
    element.isSpace = true
    Hierarchical(element)

    element.Reactive = {
        Before: 1,
        Between: 1,
        After: 1
    }
}


function RowMeasurer(startMargin) {
    let _this = this
    _this.margin = startMargin
    _this.currentX = 0

    _this.add = function (child) {
        let spaceLeft = First(Max(_this.margin, child.MarginLeft), 0)
        _this.currentX += spaceLeft + child.Width
        _this.margin = child.MarginRight
    }

    _this.finish = function (endMargin) {
        let spaceRight = First(Max(endMargin, _this.margin), 0)
        _this.currentX += spaceRight
    }
}

function RowBuilder(element) {
    let _this = this

    let startMargin = First(element.PaddingLeft, 0)
    let endMargin = First(element.PaddingRight, 0)
    let maxWidth = element.Width

    _this.margin = startMargin;
    _this.currentX = 0

    _this.currentLineHardY = 0
    _this.currentLineSoftY = element.PaddingTop
    _this.currentY = 0


    //_this.newLineHardY = 0
    //_this.newLineSoftY = 0

    _this.lineIsEmpty = true

    _this.currentLine = []

    _this.finalizeCurrentLine = function () {

        let margin = startMargin 
        let x = 0
        let newLineHardY = 0
        let newLineSoftY = 0
        
        let availableSpace = maxWidth - _this.currentX - Max(_this.margin, element.PaddingRight, 0)
        let spaceUnits = 0
        for (let i = 0; i < _this.currentLine.length; i++) {
            let child = _this.currentLine[i]
            if (child.isSpace) {
                switch (i) {
                    case 0:
                        spaceUnits += child.Before
                        break;
                    case _this.currentLine.length-1:
                        spaceUnits += child.After
                        break;
                    default:
                        spaceUnits += child.Between
                }

            }
        }
        
        let pixelBySpaceUnits = spaceUnits>0 ?  availableSpace / spaceUnits : 0

        for (let i = 0; i < _this.currentLine.length; i++){

            let child = _this.currentLine[i]

            if (child.isBlock) {
                let spaceLeft = First(Max(margin, child.MarginLeft), 0)

                var yA = Sum(_this.currentLineHardY, child.MarginTop)
                var yB = _this.currentLineSoftY
                var y = Max(yA, yB)

                x += spaceLeft
                child.LayoutX = x
                x += child.Width
                child.LayoutY = y
                margin = child.MarginRight

                var hardBottom = y + child.Height

                newLineHardY = Max(newLineHardY, hardBottom)
                newLineSoftY = Max(newLineSoftY, Sum(hardBottom, child.MarginBottom))

                //continue
            }
            
            if (child.isSpace) {
                switch (i) {
                    case 0:
                        x += child.Before * pixelBySpaceUnits
                        break;
                    case _this.currentLine.length - 1:
                        x += child.After * pixelBySpaceUnits
                        break;
                    default:
                        x += child.Between * pixelBySpaceUnits
                }
            }
        }

        let lastSpace = undefined
        if (_this.currentLine.length > 0) {
            let last = _this.currentLine[_this.currentLine.length - 1]
            if (last.isSpace) {
                lastSpace = last
            }
        }
        _this.currentLine = []
        if (lastSpace) {
            _this.currentLine.push(lastSpace)
        }


        _this.lineIsEmpty = true
        _this.margin = startMargin
        _this.currentX = 0
        _this.currentLineHardY = newLineHardY;
        _this.currentLineSoftY = newLineSoftY;

    }



    _this.layout = function (child) {
        let spaceLeft = First(Max(_this.margin, child.MarginLeft), 0)
        let spaceRight = Max(endMargin, child.MarginRight)
        if (child.isBlock) {

            if ((_this.currentX + spaceLeft + child.InternalWidth + spaceRight) > maxWidth) {
                if (_this.currentLine.length > 0) {
                    _this.finalizeCurrentLine()
                    spaceLeft = First(Max(_this.margin, child.MarginLeft), 0)
                }

                if ((spaceLeft + child.InternalWidth + spaceRight) > maxWidth) {
                    child.LayoutWidth = maxWidth - spaceLeft - spaceRight
                } else {
                    child.LayoutWidth = undefined
                }
            } else {
                child.LayoutWidth = undefined
            }
            _this.currentX += Sum(spaceLeft, child.Width)
            //console.log("_this.currentX", _this.currentX)
            _this.margin = child.MarginRight

            //_this.currentLine.push(child)

        } else {

            //_this.currentLineSpaceUnits = 0
        }
        _this.currentLine.push(child)
    }
    




}

function Row(element) {
    Block(element)

    element.isRow = true

    element.Reactive = {

        InternalWidth: () => {
            let measurer = new RowMeasurer(
                First(element.PaddingLeft, 0)
            );

            for (let child of element.children) {
                measurer.add(child)
            }
            measurer.finish();
            return measurer.currentX
        },

        //Width: () => element.InternalWidth,

        ContentWidth: undefined,
        ContentHeight: undefined,

        /*Width: () => First(
            element.LayoutWidth,
            Sum(
                element.ContentWidth,
                element.PaddingLeft,
                element.PaddingRight
            )
        ),*/
        //Height: 150//() => Sum(element.ContentHeight, element.PaddingTop, element.PaddingButtom),
    }

    new Reaction(() => {

        /*let contentWidth = undefined

        let line = []
        let lineContentWidth = 0
        let lineGrowUnits = 0
        let previousMargin = First(element.PaddingLeft,0)*/

        let builder = new RowBuilder(element);

        for (let child of element.children) {
            builder.layout(child)

        }
        builder.finalizeCurrentLine()

        var hA = Sum(builder.currentLineHardY, element.PaddingBottom)
        var hB = builder.currentLineSoftY

        element.InternalHeight = Max(hA, hB)


    })

}
</script><style>html {
    display: initial;
    position: absolute;
    overscroll-behavior-x: none;
    //overscroll-behavior: contain;
    overflow-x: hidden;
    overflow-y: hidden;
}

body {
    position: absolute;
    overflow-x: hidden;
    overflow-y: hidden;
    visibility: hidden;
    opacity: 0;
    white-space: normal;
    line-height: 1.5;
    touch-action: none;
    margin: 0;
}


input[type="checkbox"] {
    //appearance: none;
    //display: inline-block;
    background-color: #fff;
    margin: 0;
    font: inherit;
    color: currentColor;
    width: 1.15em;
    height: 1.15em;
    border: 0.15em solid currentColor;
    border-radius: 0.15em;
    transform: translateY(+0.2em);
}


/*
::-webkit-scrollbar {
    width: 50px;
    overflow: visible;
}


::-webkit-scrollbar-track {
    background: red;
    overflow: visible;
}

::-webkit-scrollbar-thumb {
    position: absolute;
    background: green;
    width: 20px;
    left: -20px;
}

::-webkit-scrollbar-thumb:hover {
    background: #6E6E6E;
}
::-webkit-scrollbar-track {
    position: absolute;
    //right: -40px;
    //top: -50px;
}*/




* {
    scrollbar-width: none;
}
::-webkit-scrollbar {
    display: none;
    //width: 0;
}

head {
    display: none;
}

body * {
    tab-size: 4;
    touch-action: inherit;
    display: inherit;
    overflow-x: visible;
    overflow-y: visible;
    //z-index: inherit;
    position: absolute;
    //position: inherit;
    margin: 0;
    visibility: inherit;
    margin-block-start: 0;
    margin-block-end: 0;
    margin-inline-start: 0;
    margin-inline-end: 0;
    line-height: inherit;
    text-decoration-color: inherit;
    color: inherit;
    justify-content: inherit;
    align-content: inherit;
    text-align: inherit;
    box-sizing: border-box;
    word-break: keep-all;
    //word-wrap: break-word;
    //overflow: clip;
    //overflow: hidden;
    white-space: inherit;
}

p {
    white-space: break-spaces;
}
p * {
    position: static;
    display: inline;
    
}


overlay {
    display: contents;
}
/*w::after {
        color: black;
        content: "\00a0";
    }*/
/*p {
        margin-left: -10px;
        //display: flex;
        //flex-wrap: wrap;
        //gap: 1em;
    }

    span {
        color: black;
        //margin: 0 -1em 0 0;
    }

    span {
        display: inline-block;
        //flex-shrink: 1;
        //word-wrap: break-word;
    }



    span::after {
        flex-grow: 1;
        display: inline-block;
        //margin-right: -10px;
        white-space: pre-line;
        content: "\00a0";
        flex-shrink: 5;
    }*/

* {
    //outline: 0.1px solid #f00 !important;
}
/*a:hover {
        opacity: 0.8;
    }

    a:visited {
        text-decoration-color: inherit;
    }*/



</style><style>@font-face {font-family: Roboto;font-weight: 700;font-style: normal;src: url(data:application/font-woff2;charset=utf-8;base64,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) format('woff2');}
@font-face {font-family: Roboto;font-weight: 300;font-style: normal;src: url(data:application/font-woff2;charset=utf-8;base64,d09GMgABAAAAAAk4ABIAAAAAEAQAAAjaAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGigbghQcNAZgAHwIWAmDPBEMCo00jB8LGgASGAE2AiQDMAQgBYJ8ByAMgjobIg4RBX1IppGycP5+BuVWVRMBEkZ3nZVkRMmevc5XgFFLRtQyEnY9nLg0c8aciAIrrxPz+OC7VS9pCi2TllB2tjPeFUUKq2awovrldpLmxIzbc/syXf37tVb3/fOIWBZrEJK1i2n95J8L0ER3D9dIJIk3KiRxSySfTiT0jIk5zUkFIC8lU22V0Hm8FgkCG7ahhuMVEthV5/8PkM75RRC+moCTcQ5Yr7+4Gps75sYHsblnvGsAmwfbJodhA+uA/5AIBrrGh+GYM0PMeiXhpRAYd+q1Ow+T4GFHb1zrJ0CxWb9M+Y1J1nfWtxMfQzLYakXqWA8GvJgFBzsc4mszcIIHe0o0+RlwpxYUwMljNxhx0jg+V2bDFqzX8Trg5NZ261sQOHHq5Yg7FacWtI0u8ZeE7pUy7AjxhErkruFOc5Dt0yrmPXTboqK5yAAySVdU10vq0nllZXnYCVj/8fg/a95tv8YGCeRG5+IzOAoJkmyjTb5/LRhxNdeCRS+A0yeCAQ8JxahCGzowiBGMYwpzsrrchCZPZX1kPWpR61brFusa6yrrCuty6xKP3fZukoNe1KMVtbgJpRjGeXgVpWiFHy9KeJP/W7HWdi0SrdMR9/+VSGZkiOwZWMuej0SOYi2/Eev4Z5Foa0CynQXHHwdP3woUniLqLFdDhFyghYl1gHq3hpxMS7NCiUeSfH1eSloVavNQkiMrlPFIfsqk+yvVVE0yJbOg05T8Um9bJ2XTp8tXqqldpnaSRFGl9lXqV6sy3am5u8IuTTtDoawLCWsxNQSk/jZjST9VyvCfQjlP0eOZjHK1QqWG1013ejW3LEs++my5Sp/1umVNUygvL0KSfIt9G4US9nI+R6EO6zWqVLrTTaGZprJJqkwN03SbqVo1n2dHDBOU8+xsRpl0X5gY5RuLjVTZjSOlyqmy5pY1r0KdnqIq1ed1y9m7KVTw0ByfQkUPzfUp1OUJZZLDklmlru4Ei46wA4er1VXkMF+Oam6aWqVS6XA4EXX6BM8b56E7D4cl1KuhXHjdq8hlvvRqyitTZrMsJDwsEhdshKSKHwEy+BARrJMZfwlpiw5jqmJlmdpSfNZ2cRubmJCwPin7SfF6wqze2+8YaEzoJwPxHQlI1EU9EPu4NkYCn4jBaBRCICaYERjRj6JRGB8K5scxIhpRMXg0aaU2EhHMGAl8IopknxPUBo6KwWgNa9SgPXi0jggRM8FI8GidGNmz7AQhgaPb7UJs72YwonGCLrZsKP4MMDT8n5Ma7wFCAlhOf1QwI9Ws4BRrysJ03SZCYDu+uppwcAEnEJHRIzluLSeye8Xz6+yiQ+jQxdmTI4Lpr/WV/pXq5sWsF8HRF5muRnD2pL2+6R/EmU9uZkjTYdLEjJzW805vETi6kH0u6Z67+7wXlnoKL+27787kd2MXfzqy+Iq+cPkbD99350uXzY6Egof6XxvvunHovuR3ProGQ/tfMvRrPgs9c89bl3fnJbMd51Q8rw5d9+z9B27gH/vmuD55wf4ji7cu188g8MOTDz7y7sO2m3G9VOL6o2b2yYmc1u9jK+S1pZGGgzOHc8sX7zqPH5lg28duebJhMPpn5t9pN4389u6B81Y+/8B+34R96Y5rl29Z+eqD1HdWvihJmQX/ECsqRyePr/j/8117Pi5K3yg9seLGZ9v3fsTTN5Ybz7/637mzr/73prtm7FsX8nNPv3bjje6NtPdHJPJH13jLflreZim5NuGZ603e7Fk8fWDx11O+fndMp5H9qrqYbPLXg1fn9u2+/sqUV4onN++0c+7xn+994FXy4rPLg+Y3WLcPoyvaLBn8x7X4C/s2Vnz/x/JRLz6esDDlg1HzRtSb3exg6Zbs5m4AoLiIxZzWkguJguRChgqSC2kWlrtaBUh0HyWpXx7Qqg6jywAl7JaKUcSc1kqfSMMSo1xGPlf8j9SKpELan2eyvoDJGeOYwjECEBlJjKr1cflfozNZZTZslLG6YMpNqITKYkUrTefRtlk5yhRBzHiWpCJw2a5q682VlSKoFyDKbZyokK6Q3mmCq84tY1ZAx/pBsXtSmE/+Krn/oM87cjpeuiIQ4aLiLv/FGhn3S6QugmqeK7kI6kgIi6rqEwVhEsHBGMq4MEVKM0SlWNUQxsEHi+PkLy9zTofyTkGQySpW7RnMZkLGCzeCDwUc8VzxuZKJoDzWhKKoYLQ7g1+BkD504WZxEdBw7FERHqqXySq7pusCiJxAXB4HC1mYPJ7zw5dEBFpshDXQWD1EEzJWkE4hk1WRmOOcEdLZH08QHS5q34sLK1jRmNM6iBz1QM1ZZ7GMfWfWC6iPhrg0cT9h6ozquq5TXdN0tmFlWsf5relz906MtvvbKC1QCoAXf4ulaekPyJDvbni3PzDLjMWA0Sw+EaQwPO8Ox6LNlje8O93NspSlOtf2YBr5Ay/EWuJR9hRGsd6YxqoxgbyBq2w1xtAAx+khuGw6DmtvFbRoCxH2oyZGp410T2tDREEXIaT6DMxIuazMrAYn4NFlKkEJTqdS2Dg0UNs0kCFVR33M04UgG3Y6G8MAzMISLEEebeDDx/J+SRqTka+Kp2IWpiOdvG03Ez7mYTamYjoWYDFfdzF89ENvdEV3DMBQdEcKTZBGBkOQwxSCJeIU+mE2ZoZoPALTsQiLMZv8C+BpirNoipZoq0Bm+ZYYgumYiaWYh8no5Ce3174rcshjJRbleGtdlrL3RA45zMS85T30xgJMRRoeOhPMMw+xwIsV+kRoWbWXYTqmIZ2ye3F3DnfXe2XJExIJKMJpgiiL0AR5xGqTaVTlwEjgETJ/dPcmlTASj9B1Mwe1midryyb1bZHMNk8b0Cag92yzv/CR0MHl49rUgTlsl8UY3KVZPTeL2dqvWybMER1zka9M/MyWmX2SLaBsO5yQSApXVNIhi9UghyxRG0ZEPsdS1bGMLFYT0XrCj16iBqIc2o/uR3cd1WXaaClaSiJDtIosVjnfUrV+rv8VRHX0EjUR7UfvoLv6jjoq39PnUNyxIVkMAAA=) format('woff2');}
@font-face {font-family: Roboto;font-weight: 400;font-style: normal;src: url(data:application/font-woff2;charset=utf-8;base64,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) format('woff2');}
</style></head><body style="font-family:Roboto;font-weight:400;font-style:normal;"><script>{let element = Constructor(PageSideMenus);element.Reactive={ContentWidth:800,SideBarsIconsSize:48,FontSize:16}}</script><material-design-icon-block data-width="24" data-height="24" data-property="LeftSideBarIcon"><script>{let element = Constructor(MaterialDesignIcon,MaterialDesignIconBlock);element.Reactive={BackgroundColor:new Color(0xFF7A596D),PaddingLeft:8,PaddingRight:8,PaddingTop:8,PaddingBottom:8,MarginLeft:8,MarginRight:8,MarginTop:8,MarginBottom:8}}</script><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" />
</svg><script>Pop()</script></material-design-icon-block><scroll-layout data-property="LeftSideBar"><script>{let element = Constructor(ScrollLayout);}</script><column data-property="Content"><script>{let element = Constructor(Column);element.Reactive={BackgroundColor:new Color(0xFF606060)}}</script><paragraph data-child><script>{let element = Constructor(Paragraph);element.Reactive={MarginLeft:0,MarginRight:0,MarginTop:0,MarginBottom:0,PaddingTop:10,PaddingBottom:10,PaddingLeft:20,PaddingRight:20}}</script><p>Material Design Icons</p><a data-property="Link" data-child><script>{let element = Constructor(Link,LinkBlock);element.Reactive={HRef:"http://staticsharp.github.io/Components/MaterialDesignIconsComponent/en",Y:() => First(element.MarginTop,0),Height:() => Sum(element.ParentBlock.Height,(-element.MarginTop),(-element.MarginLeft)),X:() => First(element.MarginLeft,0),Width:() => Sum(element.ParentBlock.Width,(-element.MarginLeft),(-element.MarginRight))}}</script><script>Pop()</script></a><block data-child><script>{let element = Constructor(Block);element.Reactive={BackgroundColor:() => element.ParentBlock.ForegroundColor,Visibility:() => (element.Parent["Link"].Hover?0.1:0),Depth:-1,Y:() => First(element.MarginTop,0),Height:() => Sum(element.ParentBlock.Height,(-element.MarginTop),(-element.MarginLeft)),X:() => First(element.MarginLeft,0),Width:() => Sum(element.ParentBlock.Width,(-element.MarginLeft),(-element.MarginRight))}}</script><script>Pop()</script></block><script>Pop()</script></paragraph><paragraph data-child><script>{let element = Constructor(Paragraph);element.Reactive={MarginLeft:0,MarginRight:0,MarginTop:0,MarginBottom:0,PaddingTop:10,PaddingBottom:10,PaddingLeft:20,PaddingRight:20}}</script><p>Paragraph</p><a data-property="Link" data-child><script>{let element = Constructor(Link,LinkBlock);element.Reactive={HRef:"http://staticsharp.github.io/Components/ParagraphComponent/en",Y:() => First(element.MarginTop,0),Height:() => Sum(element.ParentBlock.Height,(-element.MarginTop),(-element.MarginLeft)),X:() => First(element.MarginLeft,0),Width:() => Sum(element.ParentBlock.Width,(-element.MarginLeft),(-element.MarginRight))}}</script><script>Pop()</script></a><block data-child><script>{let element = Constructor(Block);element.Reactive={BackgroundColor:() => element.ParentBlock.ForegroundColor,Visibility:() => (element.Parent["Link"].Hover?0.1:0),Depth:-1,Y:() => First(element.MarginTop,0),Height:() => Sum(element.ParentBlock.Height,(-element.MarginTop),(-element.MarginLeft)),X:() => First(element.MarginLeft,0),Width:() => Sum(element.ParentBlock.Width,(-element.MarginLeft),(-element.MarginRight))}}</script><script>Pop()</script></block><script>Pop()</script></paragraph><paragraph data-child><script>{let element = Constructor(Paragraph);element.Reactive={MarginLeft:0,MarginRight:0,MarginTop:0,MarginBottom:0,PaddingTop:10,PaddingBottom:10,PaddingLeft:20,PaddingRight:20}}</script><p>Scroll Layout</p><a data-property="Link" data-child><script>{let element = Constructor(Link,LinkBlock);element.Reactive={HRef:"http://staticsharp.github.io/Components/ScrollLayoutComponent/en",Y:() => First(element.MarginTop,0),Height:() => Sum(element.ParentBlock.Height,(-element.MarginTop),(-element.MarginLeft)),X:() => First(element.MarginLeft,0),Width:() => Sum(element.ParentBlock.Width,(-element.MarginLeft),(-element.MarginRight))}}</script><script>Pop()</script></a><block data-child><script>{let element = Constructor(Block);element.Reactive={BackgroundColor:() => element.ParentBlock.ForegroundColor,Visibility:() => (element.Parent["Link"].Hover?0.1:0),Depth:-1,Y:() => First(element.MarginTop,0),Height:() => Sum(element.ParentBlock.Height,(-element.MarginTop),(-element.MarginLeft)),X:() => First(element.MarginLeft,0),Width:() => Sum(element.ParentBlock.Width,(-element.MarginLeft),(-element.MarginRight))}}</script><script>Pop()</script></block><script>Pop()</script></paragraph><paragraph data-child><script>{let element = Constructor(Paragraph);element.Reactive={MarginLeft:0,MarginRight:0,MarginTop:0,MarginBottom:0,PaddingTop:10,PaddingBottom:10,PaddingLeft:20,PaddingRight:20}}</script><p>Video Player</p><a data-property="Link" data-child><script>{let element = Constructor(Link,LinkBlock);element.Reactive={HRef:"http://staticsharp.github.io/Components/VideoPlayer/en",Y:() => First(element.MarginTop,0),Height:() => Sum(element.ParentBlock.Height,(-element.MarginTop),(-element.MarginLeft)),X:() => First(element.MarginLeft,0),Width:() => Sum(element.ParentBlock.Width,(-element.MarginLeft),(-element.MarginRight))}}</script><script>Pop()</script></a><block data-child><script>{let element = Constructor(Block);element.Reactive={BackgroundColor:() => element.ParentBlock.ForegroundColor,Visibility:() => (element.Parent["Link"].Hover?0.1:0),Depth:-1,Y:() => First(element.MarginTop,0),Height:() => Sum(element.ParentBlock.Height,(-element.MarginTop),(-element.MarginLeft)),X:() => First(element.MarginLeft,0),Width:() => Sum(element.ParentBlock.Width,(-element.MarginLeft),(-element.MarginRight))}}</script><script>Pop()</script></block><script>Pop()</script></paragraph><script>Pop()</script></column><script>Pop()</script></scroll-layout><material-design-icon-block data-width="24" data-height="24" data-property="RightSideBarIcon"><script>{let element = Constructor(MaterialDesignIcon,MaterialDesignIconBlock);element.Reactive={BackgroundColor:new Color(0xFF24597A),PaddingLeft:8,PaddingRight:8,PaddingTop:8,PaddingBottom:8,MarginLeft:8,MarginRight:8,MarginTop:8,MarginBottom:8}}</script><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path d="M12.87,15.07L10.33,12.56L10.36,12.53C12.1,10.59 13.34,8.36 14.07,6H17V4H10V2H8V4H1V6H12.17C11.5,7.92 10.44,9.75 9,11.35C8.07,10.32 7.3,9.19 6.69,8H4.69C5.42,9.63 6.42,11.17 7.67,12.56L2.58,17.58L4,19L9,14L12.11,17.11L12.87,15.07M18.5,10H16.5L12,22H14L15.12,19H19.87L21,22H23L18.5,10M15.88,17L17.5,12.67L19.12,17H15.88Z" />
</svg><script>Pop()</script></material-design-icon-block><column data-property="RightSideBar"><script>{let element = Constructor(Column);element.Reactive={BackgroundColor:new Color(0xFF24597A)}}</script><paragraph data-child><script>{let element = Constructor(Paragraph);element.Reactive={MarginLeft:0,MarginRight:0,MarginTop:0,MarginBottom:0,PaddingTop:10,PaddingBottom:10,PaddingLeft:20,PaddingRight:20}}</script><p>En</p><a data-property="Link" data-child><script>{let element = Constructor(Link,LinkBlock);element.Reactive={HRef:"http://staticsharp.github.io/Components/ScrollLayoutComponent/en",Y:() => First(element.MarginTop,0),Height:() => Sum(element.ParentBlock.Height,(-element.MarginTop),(-element.MarginLeft)),X:() => First(element.MarginLeft,0),Width:() => Sum(element.ParentBlock.Width,(-element.MarginLeft),(-element.MarginRight))}}</script><script>Pop()</script></a><block data-child><script>{let element = Constructor(Block);element.Reactive={BackgroundColor:() => element.ParentBlock.ForegroundColor,Visibility:() => (element.Parent["Link"].Hover?0.1:0),Depth:-1,Y:() => First(element.MarginTop,0),Height:() => Sum(element.ParentBlock.Height,(-element.MarginTop),(-element.MarginLeft)),X:() => First(element.MarginLeft,0),Width:() => Sum(element.ParentBlock.Width,(-element.MarginLeft),(-element.MarginRight))}}</script><script>Pop()</script></block><script>Pop()</script></paragraph><paragraph data-child><script>{let element = Constructor(Paragraph);element.Reactive={MarginLeft:0,MarginRight:0,MarginTop:0,MarginBottom:0,PaddingTop:10,PaddingBottom:10,PaddingLeft:20,PaddingRight:20}}</script><p>Ru</p><a data-property="Link" data-child><script>{let element = Constructor(Link,LinkBlock);element.Reactive={HRef:"http://staticsharp.github.io/Components/ScrollLayoutComponent/ru",Y:() => First(element.MarginTop,0),Height:() => Sum(element.ParentBlock.Height,(-element.MarginTop),(-element.MarginLeft)),X:() => First(element.MarginLeft,0),Width:() => Sum(element.ParentBlock.Width,(-element.MarginLeft),(-element.MarginRight))}}</script><script>Pop()</script></a><block data-child><script>{let element = Constructor(Block);element.Reactive={BackgroundColor:() => element.ParentBlock.ForegroundColor,Visibility:() => (element.Parent["Link"].Hover?0.1:0),Depth:-1,Y:() => First(element.MarginTop,0),Height:() => Sum(element.ParentBlock.Height,(-element.MarginTop),(-element.MarginLeft)),X:() => First(element.MarginLeft,0),Width:() => Sum(element.ParentBlock.Width,(-element.MarginLeft),(-element.MarginRight))}}</script><script>Pop()</script></block><script>Pop()</script></paragraph><script>Pop()</script></column><scroll-layout data-property="Content"><script>{let element = Constructor(ScrollLayout);}</script><column data-property="Content"><script>{let element = Constructor(Column);}</script><paragraph data-property="TopBar" data-child style="font-weight:200;font-style:normal;"><script>{let element = Constructor(Paragraph);element.Reactive={Height:() => Max(element.Root.SideBarsIconsSize,element.InternalHeight),TextAlignmentHorizontal:"Center",MarginTop:0,MarginBottom:0,FontSize:() => element.Root.SideBarsIconsSize}}</script><p>Scroll Layout</p><script>Pop()</script></paragraph><paragraph data-property="Description" data-child><script>{let element = Constructor(Paragraph);}</script><p>Контейнер вертикальным и горизонтальным скроллбарами.</p><script>Pop()</script></paragraph><block data-child><script>{let element = Constructor(Block);element.Reactive={Height:1,BackgroundColor:new Color(0xFF808080),MarginBottom:20}}</script><script>Pop()</script></block><scroll-layout data-child><script>{let element = Constructor(ScrollLayout);element.Reactive={Height:300}}</script><material-design-icon-block data-width="24" data-height="24" data-property="Content"><script>{let element = Constructor(MaterialDesignIcon,MaterialDesignIconBlock);element.Reactive={Width:1024,BackgroundColor:new Color(0xFFDB7093)}}</script><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path d="M16,10L15.8,11H13.5A0.5,0.5 0 0,0 13,11.5A0.5,0.5 0 0,0 13.5,12H15.6L14.6,17H12.5A0.5,0.5 0 0,0 12,17.5A0.5,0.5 0 0,0 12.5,18H14.4L14,20A2,2 0 0,1 12,22A2,2 0 0,1 10,20L9,15H10.5A0.5,0.5 0 0,0 11,14.5A0.5,0.5 0 0,0 10.5,14H8.8L8,10C8,8.8 8.93,7.77 10.29,7.29L8.9,5.28C8.59,4.82 8.7,4.2 9.16,3.89C9.61,3.57 10.23,3.69 10.55,4.14L11,4.8V3A1,1 0 0,1 12,2A1,1 0 0,1 13,3V5.28L14.5,3.54C14.83,3.12 15.47,3.07 15.89,3.43C16.31,3.78 16.36,4.41 16,4.84L13.87,7.35C15.14,7.85 16,8.85 16,10Z" />
</svg><script>Pop()</script></material-design-icon-block><script>Pop()</script></scroll-layout><paragraph data-child><script>{let element = Constructor(Paragraph);}</script><p>Paddings:</p><script>Pop()</script></paragraph><scroll-layout data-child><script>{let element = Constructor(ScrollLayout);element.Reactive={Height:200,PaddingLeft:20,PaddingRight:20,PaddingTop:20,PaddingBottom:20,BackgroundColor:new Color(0xFFCBC0FF)}}</script><material-design-icon-block data-width="24" data-height="24" data-property="Content"><script>{let element = Constructor(MaterialDesignIcon,MaterialDesignIconBlock);element.Reactive={Width:1024,BackgroundColor:new Color(0xFFDB7093)}}</script><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path d="M16,10L15.8,11H13.5A0.5,0.5 0 0,0 13,11.5A0.5,0.5 0 0,0 13.5,12H15.6L14.6,17H12.5A0.5,0.5 0 0,0 12,17.5A0.5,0.5 0 0,0 12.5,18H14.4L14,20A2,2 0 0,1 12,22A2,2 0 0,1 10,20L9,15H10.5A0.5,0.5 0 0,0 11,14.5A0.5,0.5 0 0,0 10.5,14H8.8L8,10C8,8.8 8.93,7.77 10.29,7.29L8.9,5.28C8.59,4.82 8.7,4.2 9.16,3.89C9.61,3.57 10.23,3.69 10.55,4.14L11,4.8V3A1,1 0 0,1 12,2A1,1 0 0,1 13,3V5.28L14.5,3.54C14.83,3.12 15.47,3.07 15.89,3.43C16.31,3.78 16.36,4.41 16,4.84L13.87,7.35C15.14,7.85 16,8.85 16,10Z" />
</svg><script>Pop()</script></material-design-icon-block><script>Pop()</script></scroll-layout><paragraph data-child><script>{let element = Constructor(Paragraph);}</script><p>Don't muss  Content and Children:</p><script>Pop()</script></paragraph><scroll-layout data-child><script>{let element = Constructor(ScrollLayout);element.Reactive={BackgroundColor:new Color(0xFFD3D3D3),PaddingLeft:10,PaddingRight:10,PaddingTop:10,PaddingBottom:10,Height:200}}</script><paragraph data-property="Content"><script>{let element = Constructor(Paragraph);element.Reactive={MarginLeft:() => element.Parent.Child(0).Width}}</script><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam eu mattis erat, vel rutrum orci. Integer eu tincidunt nisl, et eleifend nisl. Cras imperdiet suscipit mi, et tempus erat tristique vel. Pellentesque ornare, diam at imperdiet fermentum, augue velit rhoncus nunc, vehicula auctor augue turpis ac nunc. Sed faucibus lectus malesuada commodo mattis. Mauris dignissim purus vitae libero condimentum, vitae placerat quam sodales. Etiam ut erat eu nisi dignissim venenatis vitae vel enim.<br>In vitae nibh quis nunc luctus scelerisque. Vivamus molestie porta orci, eget vestibulum tortor cursus nec. Praesent sed volutpat sapien, nec maximus nisi. Donec congue ultrices convallis. Etiam nec sapien vel sem eleifend convallis. Vivamus gravida, diam ac dignissim condimentum, tortor libero hendrerit nulla, vel rhoncus tellus risus ultricies nunc. In maximus auctor tempus. Aenean consequat ipsum vel tortor consectetur cursus. Maecenas sit amet ornare leo. Quisque vitae lacus efficitur, efficitur magna eu, sollicitudin ante. Mauris vulputate eleifend nisi eu laoreet. Sed sit amet lectus eu turpis pharetra faucibus in vitae massa. Integer elementum interdum leo a ullamcorper.<br>Aenean sed erat efficitur, lobortis tortor vitae, maximus est. Phasellus id velit ut arcu gravida vulputate. Fusce sit amet turpis iaculis, posuere neque in, bibendum massa. Praesent fringilla dolor a vulputate feugiat. Maecenas velit sem, aliquet non tempus vitae, vulputate at felis. Pellentesque a erat at sapien molestie accumsan eget scelerisque arcu. In hendrerit ornare tortor sed vulputate.<br>Morbi neque sem, laoreet sollicitudin dui sed, fermentum euismod purus. Morbi nec malesuada mi. Cras placerat malesuada finibus. Nunc facilisis vulputate tellus eu condimentum. Mauris interdum malesuada quam eget ultrices. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Maecenas in maximus nunc. Donec neque eros, bibendum ut convallis at, mattis ac risus. Praesent consectetur, orci convallis euismod ullamcorper, est purus ultricies sapien, pharetra lobortis tortor erat ac purus. Nam molestie, nisl et iaculis commodo, ex ante tempor ipsum, vel fringilla dolor orci nec elit. Nullam et sapien vel lacus egestas mattis. Vestibulum cursus posuere mi et porta. Duis sed nibh ultricies, elementum sapien quis, ornare enim. Fusce laoreet metus non semper vehicula.<br>Interdum et malesuada fames ac ante ipsum primis in faucibus. Nam enim leo, feugiat sed ante non, ornare fringilla magna. Nullam maximus dignissim quam, eget vulputate risus imperdiet nec. Pellentesque vitae porttitor sapien. Etiam elementum malesuada purus in malesuada. Mauris lobortis, ipsum porttitor ornare iaculis, turpis augue rhoncus dui, at imperdiet turpis justo rutrum dui. Proin ac aliquet elit, ac lobortis sapien. In a tristique ante, at commodo magna. Nullam vel blandit mauris, vitae tempor arcu. Maecenas metus nulla, mollis finibus tristique pulvinar, pulvinar et felis. Sed dui orci, ornare vel iaculis ac, molestie ut dolor.</p><script>Pop()</script></paragraph><material-design-icon-block data-width="24" data-height="24" data-child><script>{let element = Constructor(MaterialDesignIcon,MaterialDesignIconBlock);element.Reactive={PaddingLeft:20,PaddingRight:20,PaddingTop:20,PaddingBottom:20}}</script><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path d="M3,1C1.89,1 1,1.89 1,3V5H3V3H5V1H3M7,1V3H10V1H7M12,1V3H14V5H16V3C16,1.89 15.11,1 14,1H12M1,7V10H3V7H1M14,7C14,7 14,11.67 14,14C11.67,14 7,14 7,14C7,14 7,18 7,20C7,21.11 7.89,22 9,22H20C21.11,22 22,21.11 22,20V9C22,7.89 21.11,7 20,7C18,7 14,7 14,7M16,9H20V20H9V16H14C15.11,16 16,15.11 16,14V9M1,12V14C1,15.11 1.89,16 3,16H5V14H3V12H1Z" />
</svg><script>Pop()</script></material-design-icon-block><script>Pop()</script></scroll-layout><scroll-layout data-child><script>{let element = Constructor(ScrollLayout);element.Reactive={Height:200}}</script><paragraph data-property="Content"><script>{let element = Constructor(Paragraph);element.Reactive={Width:() => element.ParentBlock.Width}}</script><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam eu mattis erat, vel rutrum orci. Integer eu tincidunt nisl, et eleifend nisl. Cras imperdiet suscipit mi, et tempus erat tristique vel. Pellentesque ornare, diam at imperdiet fermentum, augue velit rhoncus nunc, vehicula auctor augue turpis ac nunc. Sed faucibus lectus malesuada commodo mattis. Mauris dignissim purus vitae libero condimentum, vitae placerat quam sodales. Etiam ut erat eu nisi dignissim venenatis vitae vel enim.<br>In vitae nibh quis nunc luctus scelerisque. Vivamus molestie porta orci, eget vestibulum tortor cursus nec. Praesent sed volutpat sapien, nec maximus nisi. Donec congue ultrices convallis. Etiam nec sapien vel sem eleifend convallis. Vivamus gravida, diam ac dignissim condimentum, tortor libero hendrerit nulla, vel rhoncus tellus risus ultricies nunc. In maximus auctor tempus. Aenean consequat ipsum vel tortor consectetur cursus. Maecenas sit amet ornare leo. Quisque vitae lacus efficitur, efficitur magna eu, sollicitudin ante. Mauris vulputate eleifend nisi eu laoreet. Sed sit amet lectus eu turpis pharetra faucibus in vitae massa. Integer elementum interdum leo a ullamcorper.<br>Aenean sed erat efficitur, lobortis tortor vitae, maximus est. Phasellus id velit ut arcu gravida vulputate. Fusce sit amet turpis iaculis, posuere neque in, bibendum massa. Praesent fringilla dolor a vulputate feugiat. Maecenas velit sem, aliquet non tempus vitae, vulputate at felis. Pellentesque a erat at sapien molestie accumsan eget scelerisque arcu. In hendrerit ornare tortor sed vulputate.<br>Morbi neque sem, laoreet sollicitudin dui sed, fermentum euismod purus. Morbi nec malesuada mi. Cras placerat malesuada finibus. Nunc facilisis vulputate tellus eu condimentum. Mauris interdum malesuada quam eget ultrices. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Maecenas in maximus nunc. Donec neque eros, bibendum ut convallis at, mattis ac risus. Praesent consectetur, orci convallis euismod ullamcorper, est purus ultricies sapien, pharetra lobortis tortor erat ac purus. Nam molestie, nisl et iaculis commodo, ex ante tempor ipsum, vel fringilla dolor orci nec elit. Nullam et sapien vel lacus egestas mattis. Vestibulum cursus posuere mi et porta. Duis sed nibh ultricies, elementum sapien quis, ornare enim. Fusce laoreet metus non semper vehicula.<br>Interdum et malesuada fames ac ante ipsum primis in faucibus. Nam enim leo, feugiat sed ante non, ornare fringilla magna. Nullam maximus dignissim quam, eget vulputate risus imperdiet nec. Pellentesque vitae porttitor sapien. Etiam elementum malesuada purus in malesuada. Mauris lobortis, ipsum porttitor ornare iaculis, turpis augue rhoncus dui, at imperdiet turpis justo rutrum dui. Proin ac aliquet elit, ac lobortis sapien. In a tristique ante, at commodo magna. Nullam vel blandit mauris, vitae tempor arcu. Maecenas metus nulla, mollis finibus tristique pulvinar, pulvinar et felis. Sed dui orci, ornare vel iaculis ac, molestie ut dolor.</p><script>Pop()</script></paragraph><script>Pop()</script></scroll-layout><ws data-child><script>{let element = Constructor(Space);}</script><script>Pop()</script></ws><row data-property="Footer" data-child><script>{let element = Constructor(Row);element.Reactive={BackgroundColor:new Color(0xFF705035),PaddingTop:20,PaddingBottom:20,X:() => First(element.MarginLeft,0),Width:() => Sum(element.ParentBlock.Width,(-element.MarginLeft),(-element.MarginRight)),PaddingLeft:() => element.ParentBlock.PaddingLeft,PaddingRight:() => element.ParentBlock.PaddingRight}}</script><ws data-child><script>{let element = Constructor(Space);element.Reactive={Before:1.401298464324817E-45,After:1.401298464324817E-45}}</script><script>Pop()</script></ws><column data-child><script>{let element = Constructor(Column);element.Reactive={MarginLeft:10,MarginRight:10,MarginTop:20,MarginBottom:20}}</script><paragraph data-child style="font-weight:700;font-style:normal;"><script>{let element = Constructor(Paragraph);element.Reactive={FontSize:18,MarginTop:0}}</script><p>Links</p><script>Pop()</script></paragraph><paragraph data-child><script>{let element = Constructor(Paragraph);element.Reactive={MarginBottom:0}}</script><p>тут будут ссылки</p><script>Pop()</script></paragraph><script>Pop()</script></column><ws data-child><script>{let element = Constructor(Space);element.Reactive={Before:1.401298464324817E-45,After:1.401298464324817E-45}}</script><script>Pop()</script></ws><column data-child><script>{let element = Constructor(Column);element.Reactive={MarginLeft:10,MarginRight:10,MarginTop:20,MarginBottom:20}}</script><paragraph data-child style="font-weight:700;font-style:normal;"><script>{let element = Constructor(Paragraph);element.Reactive={FontSize:18,MarginTop:0}}</script><p>Column 2</p><script>Pop()</script></paragraph><paragraph data-child><script>{let element = Constructor(Paragraph);element.Reactive={MarginBottom:0}}</script><p>тут будут еще ссылки</p><script>Pop()</script></paragraph><script>Pop()</script></column><ws data-child><script>{let element = Constructor(Space);element.Reactive={Before:1.401298464324817E-45,After:1.401298464324817E-45}}</script><script>Pop()</script></ws><column data-child><script>{let element = Constructor(Column);element.Reactive={MarginLeft:10,MarginRight:10,MarginTop:20,MarginBottom:20}}</script><paragraph data-child style="font-weight:700;font-style:normal;"><script>{let element = Constructor(Paragraph);element.Reactive={FontSize:18,MarginTop:0}}</script><p>Column 3</p><script>Pop()</script></paragraph><paragraph data-child><script>{let element = Constructor(Paragraph);}</script><p>и тут будут ссылки</p><script>Pop()</script></paragraph><paragraph data-child><script>{let element = Constructor(Paragraph);}</script><p>line 2</p><script>Pop()</script></paragraph><paragraph data-child><script>{let element = Constructor(Paragraph);element.Reactive={MarginBottom:0}}</script><p>line 3</p><script>Pop()</script></paragraph><script>Pop()</script></column><ws data-child><script>{let element = Constructor(Space);element.Reactive={Before:1.401298464324817E-45,After:1.401298464324817E-45}}</script><script>Pop()</script></ws><script>Pop()</script></row><script>Pop()</script></column><script>Pop()</script></scroll-layout><script>Pop()</script><svg style="display:none;"><defs></defs></svg></body></html>