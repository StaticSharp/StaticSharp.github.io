<!doctype html><html lang="ru"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0"><title>Code</title><meta property="og:title" content="Code"><meta property="twitter:title" content="Code"><meta property="twitter:card" content="summary_large_image"><meta property="og:url" content="https://staticsharp.github.io/Components/CodeComponent/ru"><meta property="twitter:url" content="https://staticsharp.github.io/Components/CodeComponent/ru"><meta property="description" content="CodeBlock and CodeInline component."><meta property="og:description" content="CodeBlock and CodeInline component."><meta property="twitter:description" content="CodeBlock and CodeInline component."><meta property="og:type" content="website"><script>function ToCssSize(value) {
    return (value!=undefined) ? value.toFixed(50) + "px" : ""
}

function ToCssValue(value) {
    return (value != undefined) ? value : ""
}

function DepthToStyle(element) {
    return new Reaction(() => {
        element.style.zIndex = element.Depth
    })
}


function XToStyle(element) {
    return new Reaction(() => {
        element.style.left = ToCssSize(element.X)
    })
}
function YToStyle(element) {
    return new Reaction(() => {
        element.style.top = ToCssSize(element.Y)
    })
}

function WidthToStyle(element) {
    return new Reaction(() => {
        element.style.width = ToCssSize(element.Width)
    })
}

function HeightToStyle(element) {
    return new Reaction(() => {
        element.style.height = ToCssSize(element.Height)
    })
}



function Try(func, defaultValue, exceptions) {
    //console.log("try", func, defaultValue, exceptions)
    try {
        return func()
    } catch (e) {
        console.warn(e)
        if (exceptions == undefined) {
            return defaultValue
        } else {
            for (let i of exceptions) {
                if (e instanceof i) {
                    return defaultValue
                }
            }
            throw e
        }
    }
}
function IsNaNOrNull(value) {
    if (value === null) return true
    return isNaN(value)
}

function Max() {
    let result = undefined
    for (let i of arguments) {
        if (IsNaNOrNull(i)) continue;
        if (result === undefined) {
            result = i
        } else {
            result = Math.max(result, i)
        }
    }
    return result
}

function Min() {
    let result = undefined
    for (let i of arguments) {
        if (IsNaNOrNull(i)) continue;
        if (result === undefined) {
            result = i
        } else {
            result = Math.min(result, i)
        }
    }
    return result
}

function Clamp(value, min, max) {
    return Math.max(min, Math.min(max, value))
}

function Sum() {
    let resultValid = false
    let result = 0
    for (let i of arguments) {
        if (IsNaNOrNull(i)) continue;
        resultValid = true
        result += i
    }
    return resultValid ? result : undefined
}


function First() {
    for (let i of arguments) {
        if (i === undefined) continue;
        if (isNaN(i)) continue;
        if (i === null) continue;
        return i
    }
    return undefined
}


const SpaceTagName = "WS"
const WordTagName = "W"
function _deleteScript() {
    let script = document.currentScript
    let parent = script.parentElement
    parent.removeChild(script)
    return parent
}

var currentParent = undefined

function Constructor() {
    var element = _deleteScript()
    element.Parent = currentParent
    currentParent = element
    
    for (let i of arguments) {
        i(element)
    }

    /*if (element.parentElement) {
        if (element.parentElement.tagName == "OVERLAY") {
            let overlay = element.parentElement
            let parent = overlay.parentElement
            //parent.removeChild(overlay)
            //document.body.appendChild(element)
            element.Parent = parent
            parent.Overlay = element
        } else {
            element.Parent = element.parentElement
        }
    }*/

    return element;
}

function Pop() {
    let element = _deleteScript()
    if (element.Parent) {
        currentParent = element.Parent
    } else {
        delete currentParent
    }
    if (typeof (element.AfterChildren) === "function")
        element.AfterChildren()

}


function CamelToKebab(value) {
    return value.replace(
        /[A-Z]+(?![a-z])|[A-Z]/g,
        (substring, offset) => (offset ? "-" : "") + substring.toLowerCase()
    )
}


function Create(parent, ...constructors) {
    let primary = constructors[0]
    let tagName = CamelToKebab(primary.name)
    
    let element = document.createElement(tagName)
    parent.appendChild(element)
    element.Parent = parent
    for (let i of constructors) {
        i(element)
    }
    return element;
    
}





function ReactionBase(func) {
    let _this = this

    _this.triggeringProperties = new Set()
    _this.func = func
    
    _this.addTriggeringProperty = function (property) {
        _this.triggeringProperties.add(property)
        property.dependentReactions.add(_this)
    }

    _this.unsubscribeFromTriggeringProperties = function () {
        if (_this.triggeringProperties.size == 0) return

        for (let triggeringProperty of _this.triggeringProperties) {
            triggeringProperty.dependentReactions.delete(_this)
        }
        _this.triggeringProperties.clear()
    }

    _this.execute = function (object) {
        let oldReaction = Reaction.current
        Reaction.current = _this
        _this.unsubscribeFromTriggeringProperties()

        try {
            let result = _this.func(object)
            return result
        }
        finally {
            Reaction.current = oldReaction
        }
    }


    //_this.makeDirty = abstract function
    _this.dirtImmune = false
}


function Reaction(func) {
    let _this = this

    ReactionBase.call(_this, func)
    
    _this.makeDirty = function () {
        if (_this.dirtImmune)
            return;
        Reaction.deferred.add(_this)
    }

    if (Reaction.deferred) {
        Reaction.deferred.add(_this)
    } else {
        let d = Reaction.beginDeferred()

        try {
            _this.execute()
        } catch (e) {
            console.warn(e)
        }
        
        d.end()
    }
}

Reaction.prototype = Object.create(ReactionBase.prototype)
Reaction.prototype.constructor = Reaction

Reaction.beginDeferred = function () {
    if (!Reaction.deferred) {
        Reaction.deferred = new Set()
        return {
            end: function () {

                let maxIterations = 64;
                 
                while (Reaction.deferred.size > 0 & maxIterations > 0) {
                    //console.log("Reaction.deferred.end", Reaction.deferred.size)
                    let d = Array.from(Reaction.deferred)
                    for (let reaction of d) {
                        Reaction.deferred.delete(reaction)
                        try {
                            reaction.execute()
                        } catch (e) {
                            console.warn(e)
                        }
                        
                    }
                    maxIterations--
                    //d.forEach(x => x.execute())
                    //Reaction.deferred.clear()
                }

                if (maxIterations == 0) {
                    console.error("Recursive property binding", Reaction.deferred)
                }

                //let l = Reaction.deferred;
                Reaction.deferred = undefined
                //l.forEach(x => x.execute())

                

            }
        };
    }
    return {
        end: function () { }
    };
}


Reaction.beginNonReactive = function () {
    if (!Reaction.current) {
        let oldCurrent = Reaction.current
        Reaction.current = undefined
        return {
            end: function () {
                Reaction.current = oldCurrent
            }
        };
    }
    return {
        end: function () { }
    };
}



function Binding(func, onBecameDirty) {
    //console.log("function Binding(func, onChange)", onChange)
    let _this = this

    ReactionBase.call(_this, func)

    _this.dirty = true
    //_this.onBecameDirty = onBecameDirty

    
    _this.makeDirty = function () {
        if (_this.dirty)
            return

        _this.dirty = true        
        onBecameDirty()
    }
}
Binding.prototype = Object.create(ReactionBase.prototype);
Binding.prototype.constructor = Binding;



function Property(value) {

    let _this = this
    _this.name = ""
    _this.parent = null

    _this.dependentReactions = new Set()
    _this.binding = undefined

    _this.makeDirty = function () {
        _this.binding.makeDirty()
    }
    
    _this.onBindingBecameDirty = function () {
        _this.makeDependentReactionsDirty()
    }

    _this.makeDependentReactionsDirty = function () {
        /********************************************
         a deferred context is reqired here in case
         makeDirty() is called from a callback
         
         window.setTimeout(() => {
            element.Reactive.SomeProperty.makeDirty();
        },50)

         *******************************************/
        var d = Reaction.beginDeferred() 
        _this.dependentReactions.forEach(x => x.makeDirty())
        d.end()
    }

    /*_this.dependsOn = function (property) {
        if (!_this.binding)
            return false
        _this.getValue()
        for (let i of _this.binding.dependencies) {
            if (i == property)
                return true
        }
        for (let i of _this.binding.dependencies) {
            if (i.dependsOn(property))
                return true
        }
        return false
    }

    _this.getRecursiveDependencies = function () {
        let result = new Set();
        if (!_this.binding)
            return result
        _this.getValue()
        
        _this._collectRecursiveDependencies(result)
        return result
    }

    _this._collectRecursiveDependencies = function (set) {
        for (let i of _this.binding.dependencies) {
            set.add(i)
            i._collectRecursiveDependencies(set)
        }
    }*/
    _this.executionInProgress = false
    
    _this.getValue = function() {
        //console.log("getValue")
        
        //console.log("getValue", _this.name, _this.binding?.dirty)

        if (Reaction.current) {
            Reaction.current.addTriggeringProperty(_this)
        }

        if (_this.binding) { //wechat (this.binding?.dirty) not supported
            if (_this.binding.dirty) {
                if (_this.executionInProgress) {


                    if (_this.reactionsWhoReceivedOldValue == undefined) {
                        _this.reactionsWhoReceivedOldValue = new Set()
                    }
                    _this.reactionsWhoReceivedOldValue.add(Reaction.current)                    

                    //console.log("getValue", _this.name, "executionInProgress")

                    return _this.value
                }
                try {
                    var oldValue = _this.value
                    try {
                        _this.executionInProgress = true
                        _this.value = _this.binding.execute(_this.object)
                        
                    } finally {
                        _this.executionInProgress = false

                        _this.binding.dirty = false
                        //console.log("execute finished ", _this.object, _this.name, oldValue, "->", _this.value)


                        if (_this.reactionsWhoReceivedOldValue) {

                            if (_this.value !== oldValue) {

                                //var reactionsToPrint = Array.from(_this.reactionsWhoReceivedOldValue).map(x => x.func.name)
                                //console.log("ReactionsWhoReceivedOldValue", reactionsToPrint)

                                let d = Reaction.beginDeferred()
                                _this.reactionsWhoReceivedOldValue.forEach(x => x.makeDirty())
                                d.end()
                            }

                            _this.reactionsWhoReceivedOldValue = undefined                            

                        }
                        
                            
                    }

                } catch (e) {


                    

                    console.error(e)
                }                
            }
        }



        return _this.value
    }


    /*_this.setValueKeepBinding = function (value) {

        if (_this.value === value)
            return
        _this.value = value
        var d = Reaction.beginDeferred()
        _this.makeDependentReactionsDirty()
        d.end()
        if (_this.binding) {
            _this.binding.dirty = false
        }
    }*/

    _this.setValue = function(value) {
        //console.log("setValue " + value + " " + _this.onChanged.size)
        if (typeof value === 'function') {

            if (value.isBindingConstructor) {
                value = value(_this)
            }

            if (_this.binding) {
                if (_this.binding.func === value) {
                    return
                }
                _this.binding.unsubscribeFromTriggeringProperties()
                //console.log("change binding from", _this.binding.func, "to", value)
            }
            
            _this.binding = new Binding(value, _this.onBindingBecameDirty)


        } else {
            //console.log("value assigned", _this.value, "->", value, "will notify ", _this.onChanged.size)
            if (_this.binding) {
                _this.binding.unsubscribeFromTriggeringProperties()
                _this.binding = undefined
            }

            if (_this.value === value)
                return

            _this.value = value
        }

        var d = Reaction.beginDeferred()
        _this.makeDependentReactionsDirty()
        d.end()
    }



    _this.attach = function(object, name) {
        //let property = this
        _this.name = name
        _this.object = object
        let accessorDescriptor = {
            get: function () {
                return _this.getValue()
            },
            set: function (value) {
                _this.setValue(value)

            }
        }
        Object.defineProperty(object, name, accessorDescriptor);
        return _this
    }    
    _this.setValue(value)
}



Property.exists = function (target, name) {
    var propertyDescriptor = !!Object.getOwnPropertyDescriptor(target, name)
    var propertyFieldExists = target.hasOwnProperty("__" + name)
    return propertyDescriptor && propertyFieldExists
}

Property.nameAvailable = function (target, name) {
    if (Object.getOwnPropertyDescriptor(target, name))
        return false
    if (target.hasOwnProperty(name))
        return false
    return true
}

Object.defineProperty(Object.prototype, "Reactive", {
    get: function () {
        return new Proxy(
            this,
            {
                get(target, name, receiver) {
                    //console.log(`get target:${JSON.stringify(target)} name: ${name}`)
                    return target["__" + name]
                    //return Reflect.get(...arguments);
                },
                set: function (target, name, value, receiver) {
                    //console.log("set",target,name,value)
                    
                    if (target.hasOwnProperty("__" + name)) {
                        //console.log("asigning existing property", name)
                        const propertyField = target["__" + name]
                        propertyField.setValue(value)
                    } else {
                        //console.log("creating new property", name)
                        target["__" + name] = new Property(value).attach(target,name)
                    }
                }
            }
            )
    },
    set: function (obj) {
        let proxy = this.Reactive
        //console.log(proxy)

        let d = Reaction.beginDeferred()
        //отложенное выполнение реакций не нужно при создании свойств
        //тут оно используется т.к. следующий код можнт не только создать свойство
        //но и присвоить значение существующему свойству
        if (obj instanceof Object) {
            for (const [key, value] of Object.entries(obj)) {
                proxy[key] = value                
            }
        }
        d.end()
    }
});


function OnChanged(getter, action) {
    let previous = undefined
    return new Reaction(() => {
        let current = getter()
        if (current != previous) {
            let n = Reaction.beginNonReactive()
            action(previous, current)
            n.end()
            previous = current
        }
    })
}




function OnTruthify(predicate, action) {
    
    let previous = undefined
    return new Reaction(() => {        
        let current = predicate()
        if (current === true && (!previous === true)) {
            let n = Reaction.beginNonReactive()
            action()            
            n.end()
        }
        previous = current
    })
}

function PropertyTest() {

    console.group("PropertyTest")

    let root = {
        Field: 7

    }

    console.assert( Property.nameAvailable(root, "A") == true)
    console.assert( Property.nameAvailable(root, "Field") == false)


    console.assert( Property.exists(root, "A") == false)

    root.Reactive.A = 0

    console.assert( Property.exists(root, "A") == true)
    console.assert( Property.nameAvailable(root, "A") == false)

    console.assert(root.A == 0)
    root.Reactive.A = 8
    console.assert(root.A == 8)


    root.Reactive.B = () => root.A * 2
    console.assert( root.B == 16)

    root.A = 10
    console.assert( root.B == 20)

    

    root.Reactive = {
        C: 7,
        D: () => root.C,
        //E: () => root.B*4,
    }

    console.assert( Property.exists(root, "C") == true)
    console.assert( Property.exists(root, "D") == true)

    console.assert(root.D == root.C)
    //console.assert(root.E == root.B*4)

    root.Reactive.B = () => root.A * 3
    //console.assert(root.B == 30)
    //console.assert(root.E == root.A * 3 * 4)

    /*root.Reactive.B = 10
    console.assert(root.E == 40)

    root.Reactive.B = () => root.A * 3
    console.assert(root.E == 10 * 3 * 4)*/


    new Reaction(() => {
        root.Field = root.C
    })
    console.assert(root.Field == root.C)

    let bReactionResult
    new Reaction(() => {
        bReactionResult = root.B
    })
    console.assert(bReactionResult == root.B)
    console.group("root.A = 20")
    root.A = 20
    console.groupEnd()
    console.assert(bReactionResult == root.B)


    root.C = 9
    console.assert(root.Field == root.C)
    console.assert(root.D == root.C)


    root.Reactive.D = ()=>root.C+1



    console.groupEnd()
}

Object.defineProperty(Object.prototype, "Events", {
    get: function () {

        const prefix = "___"

        return new Proxy(
            this,
            {
                get(target, name, receiver) {
                    return target[prefix + name]
                },
                set: function (target, name, value, receiver) {
                    name = name.toLowerCase()

                    function add(event) {
                        target[prefix + name] = event
                        target.addEventListener(name, event.handler, event)
                    }

                    if (target.hasOwnProperty(prefix + name)) {
                        let event = target[prefix + name]
                        if (event !== undefined)
                            target.removeEventListener(name, event.handler)
                    }

                    //console.log("set", target, name, typeof (value), value)

                    if (value !== undefined) {

                        if (typeof (value) === "function") {
                            add({
                                handler: value,
                                capture: false,
                            })
                        } else if (typeof (value) === "object") {
                            if (typeof (value.handler) !== "function") {
                                console.error("If the value is an object, it must have a 'handler' field of type 'function'")
                            }
                            value.capture = false
                            add(value)
                        } else {
                            console.warn(`Type '${typeof(value)}' is invalid for event. To remove event handler assign 'undefined'`)
                        }
                    }
                }
            }
        )
    }/*,
    set: function (obj) {
    }*/
});

function GetParentElementByPredicate(firstParentToCompare, predicate) {
    var p = firstParentToCompare
    while (p != undefined) {
        if (predicate(p)) {
            
            return p
        } else {
            /*if (p.tagName == "SCROLLABLE") {
                console.error("SCROLLABLE", p.parentElement)
            }*/
            p = p.parentElement
        }
    }
    return undefined
}



function Hierarchical(element) {
    element.isHierarchical = true

    

    element.Reactive = {


        IsRoot: () => element.Parent == undefined,

        NestingDepth: () => (element.IsRoot || element.overlaySign==1) ? 0 : (element.Parent.NestingDepth + 1),

        Root: () => element.Parent.Root,
        /*Parent: undefined() => {

            let v = GetParentElementByPredicate(element.parentElement, x => x.isHierarchical)

            return v
        },*/
        ParentBlock: () => GetParentElementByPredicate(element.Parent, x => x.isBlock),
        FirstChild: undefined,
        LastChild: undefined,
        NextSibling: undefined,
    }

    if (element.Parent) {
        if (element.dataset.property) {
            element.Parent[element.dataset.property] = element

        }
        if (element.dataset.child!=undefined) {
            
            if (!element.Parent.FirstChild) {
                element.Parent.FirstChild = element
                element.Parent.LastChild = element
            } else {
                element.Parent.LastChild.NextSibling = element
                element.Parent.LastChild = element
            }
        }
        
    }

    



    element.Children = {}
    element.Children[Symbol.iterator] = function* () {
        var i = element.FirstChild
        while (i != undefined) {
            yield i
            i = i.NextSibling
        }
    };

    element.Sibling = function (id) {
        return element.Parent.Child(id)        
    }

    element.Child = function (id) {
        let i = element.FirstChild
        
        if (typeof id === "number") { 
            for (let n = 0; n < id; n++) {                
                i = i.NextSibling
            }

        } else {
            while (i) {
                if (i.id == id) {
                    return i
                }
                i = i.NextSibling
            }
        }
        //console.warn(`element ${element.tagName} do not have child "${id}"`)
        return i
    }


    
 

}

function Color() {
    let args = [...arguments]
    let _this = this

    _this.r = 0
    _this.g = 0
    _this.b = 0
    _this.a = undefined

    if (args.length == 0) {
        return
    }

    if (args.length == 1) {
        let input = args[0]
        if (typeof input == 'number') {
            _this.r = (input & 0xFF) / 255
            _this.g = ((input & 0xFF00) >>> 8) / 255
            _this.b = ((input & 0xFF0000) >>> 16) / 255
            _this.a = ((input & 0xFF000000) >>> 24) / 255
            return;
        }

        if (typeof input == 'string') {
            
            if (input.substr(0, 1) == "#") {
                var collen = (input.length - 1) / 3;
                var fact = [17, 1, 0.062272][collen - 1] / 255;
                _this.r = parseInt(input.substr(1, collen), 16) * fact
                _this.g = parseInt(input.substr(1 + collen, collen), 16) * fact
                _this.b = parseInt(input.substr(1 + 2 * collen, collen), 16) * fact 
                return
            }

            //} return input.split("(")[1].split(")")[0].split(",").map(x => +x)

        }

        console.warn("Color: Invalid arguments", input)
    }

    

    if ((args.length >= 3) & (args.length <= 4)) {
        if (args.slice(0, 3).some(x => (typeof x) != 'number')) {
            console.warn("Color: Invalid arguments types", args)
            return;
        }

        _this.r = args[0]
        _this.g = args[1]
        _this.b = args[2]

        if (args.length == 4) {
            if ((typeof args[3]) != 'number') {
                console.warn("Color: Invalid arguments types", args)
                return;
            }
            _this.a = args[3]
        }
        return
    }
    
    console.warn("Color: Invalid arguments", args)

}

Color.prototype.toString = function () {
    let a = this.a
    if (a == undefined)
        a = 1
    return `rgba(${Math.round(255 * this.r)},${Math.round(255 * this.g)},${Math.round(255 * this.b)},${a})`
}



Color.Lerp = function (a, b, t) {
    console.log(b)
    return a.Lerp(b,t)
}

Color.prototype.Lerp = function (targetColor, amount) {
    var bk = (1 - amount);
    var a = First(this.a * bk + targetColor.a * amount, this.a, targetColor.a);
    var r = this.r * bk + targetColor.r * amount;
    var g = this.g * bk + targetColor.g * amount;
    var b = this.b * bk + targetColor.b * amount;
    return new Color(r, g, b, a);
}

Color.prototype.contrastColor = function (contrast = 1) {
    var grayscale = (0.2125 * this.r) + (0.7154 * this.g) + (0.0721 * this.b);
    var blackOrWhite = (grayscale > 0.5) ? new Color(0, 0, 0, 1) : new Color(1, 1, 1, 1);
    return this.Lerp(blackOrWhite, contrast);
}

function BaseModifier(element) {
    Hierarchical(element)

    if (element.parentElement.tagName == "A") {
        if (window.location.protocol == "file:") {
            let a = element.parentElement
            let href = a.getAttribute("href")
            let AbsoluteUrlRegExp = new RegExp('^(?:[a-z+]+:)?//', 'i')
            if (!AbsoluteUrlRegExp.test(href)) {
                a.setAttribute("href", href + ".html")
            }
        }        
    }
    


    //var extension = (window.location.protocol == "file:") ? ".html" : ""
    

    //window.location.replace(matchLanguage([{{ languages }}]) + extension)



    element.isModifier = true

    element.Reactive = {
        Hover: false,
        Selectable: undefined,

        BackgroundColor: undefined,
        HierarchyBackgroundColor: () => element.BackgroundColor || element.Parent.HierarchyBackgroundColor,

        ForegroundColor: () => { 
            if (element.BackgroundColor != undefined)
                return element.BackgroundColor.contrastColor()
            else
                return undefined
        },
        HierarchyForegroundColor: () => element.ForegroundColor || element.Parent.HierarchyForegroundColor,

        TextDecorationColor: () => {
            if (element.ForegroundColor != undefined)
                return element.ForegroundColor
            else
                return undefined
        },

        FontSize: undefined,
        HierarchyFontSize: () => element.FontSize || element.Parent.HierarchyFontSize,

        Radius: undefined,
        RadiusTopLeft: () => element.Radius,
        RadiusTopRight: () => element.Radius,
        RadiusBottomLeft: () => element.Radius,
        RadiusBottomRight: () => element.Radius,

        Visibility: 1
    }

    new Reaction(() => {
        let visibility = element.Visibility
        if (visibility == 0) {
            element.style.visibility = "hidden"
            element.style.opacity = ""
        } else if (visibility == 1) {
            element.style.visibility = ""
            element.style.opacity = ""
        } else {
            element.style.opacity = visibility
            element.style.visibility = ""
        }        
    })


    new Reaction(() => {
        element.style.borderTopLeftRadius       = ToCssSize(element.RadiusTopLeft)
        element.style.borderTopRightRadius      = ToCssSize(element.RadiusTopRight)
        element.style.borderBottomLeftRadius    = ToCssSize(element.RadiusBottomLeft)
        element.style.borderBottomRightRadius   = ToCssSize(element.RadiusBottomRight)
    })



    new Reaction(() => {
        let selectable = element.Selectable
        if (selectable!=undefined)
            element.style.userSelect = element.Selectable ? "text" : "none"
        else
            element.style.userSelect = ""
    })
    

    new Reaction(() => {
        element.style.backgroundColor = ToCssValue(element.BackgroundColor)
    })

    new Reaction(() => {
        element.style.color = ToCssValue(element.ForegroundColor)
    })

    new Reaction(() => {
        element.style.textDecorationColor = ToCssValue(element.TextDecorationColor)
    })
}


/*function CalcLeft(container, child) {
    if (container.PaddingLeft != undefined) {
        return Math.max(container.PaddingLeft, First(child.MarginLeft,0))
    }
    if (container.MarginLeft == undefined) {
        return First(child.MarginLeft,0)
    }
    return Math.max(child.MarginLeft - container.MarginLeft, 0)
}*/

function CalcOffset(container, child, sideName) {
    let paddingName = "Padding" + sideName
    let marginName = "Margin" + sideName
    if (container[paddingName] != undefined) {
        return Math.max(container[paddingName], First(child[marginName], 0))
    }
    if (container[marginName] == undefined) {
        return First(child[marginName], 0)
    }
    if (child[marginName] == undefined) {
        return 0
    }
    return Math.max(child[marginName] - container[marginName], 0)
}

function GetClipRect(clippingElement, contentX, contentY, contentWidth, contentHeight ) {
    let left = -contentX
    let top = -contentY
    let right = -clippingElement.Width + contentWidth + contentX
    let bottom = -clippingElement.Height + contentHeight + contentY
    let offsets = `${top}px ${right}px ${bottom}px ${left}px`
    let round = ""
    if (
        clippingElement.RadiusTopLeft != undefined
        || clippingElement.RadiusTopRight != undefined
        || clippingElement.RadiusBottomLeft != undefined
        || clippingElement.RadiusBottomRight != undefined
    ) {
        round = ` round ${clippingElement.RadiusTopLeft || 0}px ${clippingElement.RadiusTopRight || 0}px ${clippingElement.RadiusBottomRight || 0}px ${clippingElement.RadiusBottomLeft || 0}px`
    }
    return `inset(${offsets}${round})`
}


function Block(element) {
    

    BaseModifier(element)

    element.isBlock = true



    element.Reactive = {
        
        Depth: 0,

        PaddingLeft: undefined,
        PaddingTop: undefined,
        PaddingRight: undefined,
        PaddingBottom: undefined,

        MarginLeft: undefined,
        MarginTop: undefined,
        MarginRight: undefined,
        MarginBottom: undefined,

        LayoutX: undefined,
        LayoutY: undefined,
        LayoutWidth: undefined,
        LayoutHeight: undefined,

        

        InternalWidth: undefined,
        InternalHeight: undefined,


        X: () => First(element.LayoutX,0),
        Y: () => First(element.LayoutY,0),

        AbsoluteX: () => element.IsRoot ? 0 : Sum(element.Parent.AbsoluteX, element.Parent.ScrollXActual, element.X),
        AbsoluteY: () => element.IsRoot ? 0 : Sum(element.Parent.AbsoluteY, -element.Parent.ScrollYActual, element.Y),

        Width: e => First(e.LayoutWidth, e.InternalWidth),
        Height: e => First(e.LayoutHeight, e.InternalHeight),

        ClipByParent: false
        
    }

    DepthToStyle(element)


    XToStyle(element);
    YToStyle(element);
    WidthToStyle(element)
    HeightToStyle(element)

    //element.style.clipPath = "path('M 0 200 L 0,75 A 5,5 0,0,1 150,75 L 200 200 z')"

    new Reaction(() => {
        if (element.Parent == undefined)
            return

        if (element.ClipByParent) {

            element.style.clipPath = GetClipRect(element.Parent, element.X, element.Y, element.Width, element.Height)


            /*let left = -element.X
            let top = -element.Y
            let right = -element.Parent.Width + element.Width - element.X
            let bottom = -element.Parent.Height + element.Height - element.Y
            let offsets = `${top}px ${right}px ${bottom}px ${left}px`
            let round = ""
            if (
                element.Parent.RadiusTopLeft != undefined
                || element.Parent.RadiusTopRight != undefined
                || element.Parent.RadiusBottomLeft != undefined
                || element.Parent.RadiusBottomRight != undefined
            ) {
                round = ` round ${element.Parent.RadiusTopLeft || 0}px ${element.Parent.RadiusTopRight || 0}px ${element.Parent.RadiusBottomRight || 0}px ${element.Parent.RadiusBottomLeft || 0}px`
            }
            element.style.clipPath = `inset(${offsets}${round})`*/
        } else {
            element.style.clipPath = ""
        }

    })


    


    new Reaction(() => {
        element.style.fontSize = ToCssSize(element.FontSize)
    })

    element.Events.MouseEnter = () => element.Hover = true
    element.Events.MouseLeave = () => element.Hover = false


    


}


function Page(element) {
    element.classList.add("js")
    element.isRoot = true
    let loadingDeffered = Reaction.beginDeferred()

    Block(element)

    var html = document.body.parentNode
    function getWindowWidth() {
        return html.clientWidth
        //return document.documentElement.clientWidth //window.innerWidth
    }
    function getWindowHeight() {       
        return html.clientHeight
        //return window.innerHeight // document.documentElement.clientHeight
    }


    let animationFrame = 0
    window.Reactive = {
        Root: element,

        AnimationFrame: () => {
            animationFrame++
            window.requestAnimationFrame(() => {
                window.Reactive.AnimationFrame.makeDirty()
            });
            return animationFrame
        },

        UserInteracted: false,
        DevicePixelRatio: window.devicePixelRatio,
        Touch: false,
    }

    let touchMedia = window.matchMedia("(pointer: coarse)")
    window.Touch = touchMedia.matches
    touchMedia.onchange = (e) => {
        window.Touch = e.matches
    }

    function createDevicePixelRatioCallback(func) {
        let matchMedia = window.matchMedia(`screen and (resolution: ${window.devicePixelRatio}dppx)`)
        matchMedia.addEventListener(
            "change",
            () => {
                func()
                createDevicePixelRatioCallback(func)
            },
            { once: true }
        );
    }
    createDevicePixelRatioCallback(() => window.DevicePixelRatio = window.devicePixelRatio)



    element.Reactive = {
        Root: element,        

        LayoutWidth: undefined,
        LayoutHeight: undefined,

        FontSize: 16,
        HierarchyFontSize: () => element.FontSize,

        BackgroundColor: new Color("#fff"),

        HierarchyBackgroundColor: () => element.BackgroundColor,
        HierarchyForegroundColor: () => element.ForegroundColor,

    }

    new Reaction(() => {
        element.LayoutWidth = getWindowWidth()
        element.LayoutHeight = getWindowHeight()
    })

    /*window.ontouchend = () => {
        console.log("ontouchend")
        window.UserInteracted = true
    }*/
    window.onmousedown = () => {
        window.UserInteracted = true
    }

    /*function PrintWindowSize() {
        console.log("onresize", window.innerWidth, window.innerHeight, document.documentElement.clientWidth, document.documentElement.clientHeight, document.body.parentNode.clientHeight)
    }*/
    //PrintWindowSize()

    window.onresize = function (event) {
        //let startTime = performance.now()
        let d = Reaction.beginDeferred()
        element.LayoutWidth = getWindowWidth()
        element.LayoutHeight = getWindowHeight()
        //PrintWindowSize()
        d.end()
        //console.log("resize", performance.now() - startTime)
    }
    
    let loadEventsToWait = 2
    function onLoadEvent() {
        loadEventsToWait--
        if (loadEventsToWait == 0) {
            //document.body.style.display = "block"
            //document.body.style.visibility = "hidden"
            console.log("-------------Reactions------------", performance.now());
            loadingDeffered.end()
            console.log("-------------Reactions-done-------", performance.now());
            

            
            document.body.style.visibility = "visible"
            //document.body.style.opacity = 1

            if (location.hash !== "") {
                location.href = location.hash
            }



            /*let d = Reaction.beginDeferred()
            element.WindowWidth = getWindowWidth()
            element.WindowHeight = getWindowHeight()
            d.end()*/
        }
    }

    document.fonts.ready
        .then(() => {
            console.log("-------------Fonts ready--", performance.now());
            onLoadEvent()            
        })

    window.addEventListener("DOMContentLoaded", function (event) {
        console.log("------DOMContentLoaded--", performance.now());
        onLoadEvent()
    })



    

}




    /*var template = document.createElement('div');
    template.style.display = "contents"
    element.appendChild(template);
    new Reaction(() => {
        template.innerHTML = element.Html;

    })*/

    //element.insertAdjacentHTML('beforeend', `<svg width="800" viewBox="0 0 800 600" x="2 ${200}"><circle cx="500" cy="500" cx="500"r="20"></circle></svg>`);
    //console.log(`265 && element.ContentWidth`)



    /*element.Reactive =
    {
        A: () => {
            console.log("Get A")
            return Max(element.B, element.E)
        },

        //C: () => { Max(element.E, element.A) },

        E: () => {
            console.log("Get E")
            return element.A
        },

        B: 6
    }

    //let d = Reaction.beginDeferred()

    new Reaction(() => {
        console.group("Reaction A:")
        console.log("element.Reactive.E.binding.dirty:", element.Reactive.E.binding.dirty)
        console.log("element.Reactive.A.binding.dirty:", element.Reactive.A.binding.dirty)

        console.log("Reaction A:", element.A)

        console.groupEnd()
    })

    //d.end()

*/
    


    /*new Reaction(() => {
        console.log("Reaction E:", element.E)
    })

    console.log("element.Reactive.E.binding.dirty:", element.Reactive.E.binding.dirty)
    console.log("element.Reactive.A.binding.dirty:", element.Reactive.A.binding.dirty)*/

    




    //PropertyTest()

    

    

    /*let previous = this.Content
    let onChanged = function (previous, current) {
        if (current) {
            this.Content.InnerWidth =
                () => Math.min(this.Content.Width, parameters.ContentWidth)
        }
    }
    new Reaction(() => {
        let current = this.Content
        if (current != previous) {
            onChanged(previous, current)
            previous = current
        }
    })*/


    /*new Reaction(() => {

        if (this.Content)
            console.log("Content.PaddingLeft changed", this.Content.PaddingLeft)
    })*/



 

    //console.log(parameters.ContentWidth)


    /*new Property().attach(element, "Content")

    new Property(window.innerWidth).attach(window, "InnerWidth")
    new Property(window.innerHeight).attach(window, "InnerHeight")


    const LeftBarSize = 200
    const RightBarSize = 50

    new Reaction(() => {
        if (element.Content) {

            element.Content.style.left = LeftBarSize+"px"

            element.Content.MaxInnerWidth = parameters.ContentWidth
            element.Content.Width = window.InnerWidth - LeftBarSize - RightBarSize
        }
    })


    

    */


    /*element.css({
        margin: "0",
    })
    let leftBarWidth = 0;
    let rightBarWidth = 0;

    //contentWidth = 800;

    element.onAnchorsChanged = []
    element.anchors = {}
    var leftBar = element.querySelector("#leftBar");
    var rightBar = document.getElementById("#rightBar");

    leftBarWidth = leftBar == null ? 0 : leftBar.width;
    rightBarWidth = rightBar == null ? 0 : rightBar.width;

    function updateHeaderWidth() {
        let left = element.anchors.textLeft;
        let right = element.anchors.textRight;
        header.style.marginLeft = left + "px";
        header.style.width = right - left + "px";
    }



    function updateAnchors() {
        

        var leftBar = element.querySelector("#leftBar");
        var rightBar = element.querySelector("#rightBar");
        leftBarWidth = leftBar == null ? 0 : leftBar.offsetWidth;
        rightBarWidth = rightBar == null ? 0 : rightBar.offsetWidth;
        const textMargin = 12;
        let width = window.innerWidth;
        let wideAnchorsCollapsed = width < (leftBarWidth + rightBarWidth + contentWidth);
        element.anchors.wideLeft = wideAnchorsCollapsed ? 0 : leftBarWidth;
        element.anchors.wideRight = wideAnchorsCollapsed ? width : width - rightBarWidth;
        element.anchors.wideAnchorsCollapsed = wideAnchorsCollapsed;
        let fillAnchorsCollapsed = width < contentWidth;
        let center = 0.5 * (element.anchors.wideLeft + element.anchors.wideRight);
        element.anchors.fillLeft = fillAnchorsCollapsed ? 0 : (center - 0.5 * contentWidth);
        element.anchors.fillRight = fillAnchorsCollapsed ? width : (center + 0.5 * contentWidth);

        element.anchors.textLeft = Math.max(element.anchors.fillLeft, element.anchors.wideLeft + textMargin);
        element.anchors.textRight = Math.min(element.anchors.fillRight, element.anchors.wideRight - textMargin);

        element.onAnchorsChanged.map(x => x());
        if (wideAnchorsCollapsed) {
            document.getElementById("rightBar").style.visibility = "hidden";
            document.getElementById("leftBar").style.visibility = "hidden";
        } else {
            document.getElementById("rightBar").style.visibility = "";
            document.getElementById("leftBar").style.visibility = "";
        }

    }

    DetectSwipe(element, swiper);

    function swiper(direction, swipe, touchEnd, event) {
        let getTranslate = (offsetWidth) => {
            var value = direction == 'left' || direction == 'right' ? swipe.swipeX : swipe.swipeY;
            let percent = toPercents(Math.abs(value), offsetWidth);
            let translate = percent > 0 ? percent : 0;
            return translate;
        }

        let showChildren = (element) => Array.from(element.children).forEach(x => {
            x.css({ visibility: "visible" });
        });

        if (direction == 'left') {
            let allSwiped = event.path.map(x => x.scrollLeft == null ? true : x.scrollLeft === x.scrollWidth - x.clientWidth).every(x => x == true);
            if (allSwiped) {
                let startY = swipe.clientStartY;
                let touchedElementSpace = menusHitBoxes.find(x => x.top <= startY && x.bottom >= startY);
                if (touchedElementSpace == null) { return; }
                let selectedMenu = touchedElementSpace.element
                if (selectedMenu.position == 'minimizedRight') {
                    showChildren(selectedMenu);
                    let translate = 100 - getTranslate(selectedMenu.offsetWidth);
                    selectedMenu.css({ transform: `translateX(clamp(0%, ${translate}%, 70%))` });
                }
            }
        } else {
            //menusHitBoxes.forEach(x => x.element.css({ transform: 'translateX(70%)' }));
        }
    }

    menusHitBoxes = [];


    window.addEventListener("resize", updateAnchors);
    document.addEventListener("DOMContentLoaded", function() {

        element.style.display = "";
        rightBarWidth = document.getElementById("rightBar").scrollWidth;
        leftBarWidth = document.getElementById("leftBar").scrollWidth;
        header = document.getElementById("Header");
        if (header != null) {
            element.onAnchorsChanged.push(updateHeaderWidth);
        }
        updateAnchors()
        var rightBar = document.getElementById('rightBar');
        var children = Array.from(rightBar.children)
        children.forEach(x => {
            var rect = x.getBoundingClientRect();
            let element = {
                element: x,
                top: rect.top,
                bottom: rect.bottom
            }
            menusHitBoxes.push(element);
        });
    });*/


var Storage = {}

Storage.Elements = {}

Storage.Restore = function (name, getter) {

    var valueString = localStorage.getItem(name)

    if (Storage.Elements[name] == undefined) {
        Storage.Elements[name] = new Reaction(() => {
            var newValue = getter()
            localStorage.setItem(name, typeof (newValue) + " " + newValue)
        })
    }

    if (valueString != null) {
        var seperator = valueString.indexOf(' ')
        var type = valueString.substring(0, seperator)
        var value = valueString.substring(seperator + 1)

        if (type == "undefined") {
            return undefined
        }
        if (type == "number") {
            return Number(value)
        }
        if (type == "boolean") {
            return (value === 'true')
        }
        if (type == "string") {
            return value
        }

    } else {
        return undefined
    }

    

}
var glass = undefined

function getGlass() {
    if (!glass) {
        glass = document.createElement("glass")
        document.body.appendChild(glass)
        Glass(glass)
    }
    return glass
}

const glassZIndex = 99
function Glass(element) {
    element.style.width = "100vw"
    element.style.height = "100vh"
    //element.style.backgroundColor = "black"
    element.style.zIndex = glassZIndex
    element.style.position = "fixed"


    element.Reactive = {
        Color: new Color(0xff000000),
        Visibility: 1,
        MaxOpacity: 0.7
    }
    new Reaction(() => {
        element.style.backgroundColor = element.Color
    })

    new Reaction(() => {
        //element.style.backdropFilter = `blur(${element.Visibility*10}px)`;
        element.style.opacity = element.Visibility * element.MaxOpacity
        element.style.display = element.Visibility == 0 ? "none" : "block"
    })
}

function lerp(a, b, t) {
    return a + t * (b - a)
}

function AnimateTo(targetValue, duration) {
    
    let result = (property) => {
        
        let startValue = property.value
        let startTime = performance.now()

        return () => {
            let elapsed = performance.now() - startTime
            
            if (elapsed < duration) {
                window.AnimationFrame
            }
            let t = (typeof targetValue === "function") ? targetValue() : targetValue
            let mormalizedTime = Math.min(elapsed / duration, 1)
            
            return lerp(startValue, t, mormalizedTime)
        }
    }
    result.isBindingConstructor = true
    return result
}




function PageSideMenus(element) {
    Page(element)


 
    let glass = getGlass()

    const minSwipeToOpen = 40
    const minSwipeToClose = 20
    const swipeThreshold = 10

    let toggle = false
    element.Events.Click = () => {
        
        /*toggle = !toggle
        element.ContentWidth = AnimateTo(
            () => toggle ? (element.WindowWidth - 100) : 500,
            10000)*/
    }

    element.Reactive = {
        ContentWidth: 960,
        SideBarsIconsSize: 48,

        BarsCollapsed: () =>
            element.Width < Sum(
                element.ContentWidth,
                element.LeftSideBar ? element.LeftSideBar.Width : 0,
                element.RightSideBar ? element.RightSideBar.Width : 0),

        //Content: () => element.Child("Content"),

        SideBarOpen: 0, //-1 left , 1 right

        //LeftSideBar: () => element.LeftSideBar,
        //LeftSideBarIcon: () => element.LeftSideBarIcon,

        //RightSideBar: () => element.RightSideBar,
        //RightSideBarIcon: () => element.RightSideBarIcon,

        TopBar: () => element.Content.Content.TopBar,

        Footer: undefined,

        SwipeXAboveThreshold: () => {
            if (element.SwipeX > swipeThreshold)
                return element.SwipeX - swipeThreshold
            if (element.SwipeX < -swipeThreshold)
                return element.SwipeX + swipeThreshold
            return 0
        },


        MinSwipeToOpen_LeftSideBar: () => element.LeftSideBar ? Min(minSwipeToOpen, element.LeftSideBar.Width) : undefined,
        MinSwipeToOpen_RightSideBar: () => element.RightSideBar ? Min(minSwipeToOpen, element.RightSideBar.Width) : undefined,

        SwipeX: 0,
        SwipeY: 0,
        Swipe: false,

        LeftSideBarSwipeProgress : 0,
        RightSideBarSwipeProgress: 0,

    }




    let startX = 0
    let startY = 0

    const iconMargin = 10
    const collapsedIconWidth = 6
    const collapsedIconHeight = 120
    

    function touchStart() {
        var touch = event.touches[0];
        startX = touch.clientX;
        startY = touch.clientY;
        
    }
    function horizontalTouchMove() {
        if (!event.cancelable) return
        var touch = event.touches[0];
        //console.log("horizontalTouchMove", event.path)
        let d = Reaction.beginDeferred()
        element.SwipeX = touch.clientX - startX
        element.SwipeY = touch.clientY - startY
        element.Swipe = true
        d.end()
        event.preventDefault()
    }


    element.pan = function (x, y) {
        console.log("pan",element.tagName,x,y)
        return [x,y]
    }

    
    document.Events.TouchStart = {
        handler: () => {
            //if (event.pointerType != "touch") return

            //console.log("document TouchStart", event.path)
            touchStart()
            document.Events.TouchMove = () => {
                //console.log("document PointerMove", event.path, event.clientX, event.cancelable)
                if (event.cancelable) {
                    var touch = event.touches[0];
                    let deltaX = Math.abs(touch.clientX - startX)
                    //console.log("deltaX", deltaX, swipeThreshold)
                    if (deltaX > swipeThreshold) {
                        event.preventDefault()
                        //console.log("horizontalTouchMove...")
                        element.Events.TouchMove = {
                            handler: horizontalTouchMove,
                            passive: false
                        }
                    }
                } else {
                    //console.log("PointerMove = undefined")
                    document.Events.TouchMove = undefined
                    document.Events.TouchEnd = undefined
                }
            }
            element.Events.TouchEnd = () => {
                //console.log("TouchEnd")
                element.Swipe = false
                element.Events.TouchMove = undefined
                element.Events.TouchEnd = undefined
            }
        },
        passive: false
    }
    

    glass.Events.TouchStart = {
        handler: () => {
            touchStart()

            glass.Events.TouchMove = {
                handler: horizontalTouchMove,
                passive: false
            }

            glass.Events.TouchEnd = () => {
                element.Swipe = false
                glass.Events.TouchMove = undefined
                glass.Events.TouchEnd = undefined
            }
        },
        passive: false
    }

    glass.Events.Click = () => {
        element.SideBarOpen = 0
    }

    


    new Reaction(() => {
        if (element.TopBar) {
            if (element.LeftSideBar && element.BarsCollapsed) {
                element.TopBar.MarginLeft = element.SideBarsIconsSize + iconMargin
            } else {
                element.TopBar.MarginLeft = 0
            }
        }
    })
    new Reaction(() => {
        if (element.TopBar) {
            if (element.RightSideBar && element.BarsCollapsed) {
                element.TopBar.MarginRight = element.SideBarsIconsSize + iconMargin
            } else {
                element.TopBar.MarginRight = 0
            }
        }
    })
    new Reaction(() => {
        if (element.TopBar) {
            if ((element.RightSideBar || element.LeftSideBar) && element.BarsCollapsed) {
                element.TopBar.Height = () => Max(element.TopBar.InternalHeight, element.SideBarsIconsSize)
            } else {
                element.TopBar.Height = () => First(element.TopBar.InternalHeight, element.SideBarsIconsSize)
            }
        }
    })




    


    new Reaction(() => {
        if (element.LeftSideBar) {
            element.LeftSideBar.Depth = glassZIndex + 1
            //element.LeftSideBar.style.position = "fixed"
            element.LeftSideBar.Height = () => element.Height
        }
    })

    new Reaction(() => {
        if (element.RightSideBar) {
            element.RightSideBar.Depth = glassZIndex + 1
            //element.RightSideBar.style.position = "fixed"
            element.RightSideBar.Height = () => element.Height
        }
    })




    OnTruthify(
        () => !element.Swipe,
        () => {
            if (element.BarsCollapsed) {
                if (element.SideBarOpen == 0) {
                    if (element.LeftSideBar && element.SwipeXAboveThreshold > element.MinSwipeToOpen_LeftSideBar) {
                        element.SideBarOpen = -1
                        return
                    }
                    if (element.RightSideBar && element.SwipeXAboveThreshold < -element.MinSwipeToOpen_RightSideBar) {
                        element.SideBarOpen = 1
                        return
                    }
                } else {
                    if (Math.sign(element.SwipeXAboveThreshold) == Math.sign(element.SideBarOpen) && Math.abs(element.SwipeXAboveThreshold) > minSwipeToClose) {
                        element.SideBarOpen = 0
                    }
                }
            }
        }
    )

    new Reaction(() => {
        if (!element.BarsCollapsed) {
            element.SideBarOpen = 0
        }
    })

    //Glass Visibility
    new Reaction(() => {
        if (!element.BarsCollapsed) {
            glass.Visibility = 0
        } else {
            if (element.SideBarOpen == 0) {
                if (element.Swipe) {
                    if (element.SwipeXAboveThreshold > 0) {
                        if (element.LeftSideBar) {
                            glass.Visibility = Math.min(Math.max(element.SwipeXAboveThreshold / element.MinSwipeToOpen_LeftSideBar, 0), 1)
                            return
                        }
                    }
                    if (element.SwipeXAboveThreshold < 0) {
                        if (element.RightSideBar) {
                            glass.Visibility = Math.min(Math.max(-element.SwipeXAboveThreshold / element.MinSwipeToOpen_RightSideBar, 0), 1)
                            return
                        }
                    }
                }
            } else {
                if (element.Swipe) {
                    glass.Visibility = Math.min(Math.max(1 - element.SwipeXAboveThreshold * element.SideBarOpen / minSwipeToClose, 0), 1)
                    return
                } else {
                    glass.Visibility = 1
                    return
                }
            }
        }
        glass.Visibility = 0

    })


    new Reaction(() => {
        if (element.LeftSideBar) {
            if (element.BarsCollapsed) {
                if (element.SideBarOpen == 0) {
                    if (element.Swipe) {
                        element.LeftSideBar.X = -element.LeftSideBar.Width + Clamp(element.SwipeXAboveThreshold, 0, element.LeftSideBar.Width)
                    } else {
                        element.LeftSideBar.X = -element.LeftSideBar.Width
                    }
                } else if (element.SideBarOpen == -1) {
                    if (element.Swipe) {
                        element.LeftSideBar.X = Clamp(element.SwipeXAboveThreshold, -element.LeftSideBar.Width, 0)

                    } else {
                        element.LeftSideBar.X = 0
                    }
                }
            } else {
                element.LeftSideBar.X = 0
            }
        }
    })

    new Reaction(() => {
        
        if (element.RightSideBar) {
            if (element.BarsCollapsed) {
                if (element.SideBarOpen == 0) {
                    if (element.Swipe) {
                        element.RightSideBar.X = element.Width + Clamp(element.SwipeXAboveThreshold, -element.RightSideBar.Width, 0)
                    } else {
                        element.RightSideBar.X = element.Width
                    }
                } else if (element.SideBarOpen == 1) {
                    if (element.Swipe) {
                        element.RightSideBar.X = element.Width - element.RightSideBar.Width + Clamp(element.SwipeXAboveThreshold, 0, element.RightSideBar.Width)
                    } else {
                        element.RightSideBar.X = element.Width - element.RightSideBar.Width
                    }
                } else if (element.SideBarOpen == -1) {
                    element.RightSideBar.X = element.Width 
                }
            } else {
                element.RightSideBar.X = element.Width - element.RightSideBar.Width
            }
        }
    })


    new Reaction(() => {

        let LeftBarSize = (element.LeftSideBar && !element.BarsCollapsed) ? Max(element.LeftSideBar.Width, 0) : 0

        let RightBarSize = (element.RightSideBar && !element.BarsCollapsed) ? Max(element.RightSideBar.Width, 0) : 0

        let width = element.Width - LeftBarSize - RightBarSize
        let innerWidth = Math.min(width, element.ContentWidth)
        let contentSpace = (width - innerWidth) * 0.5

        if (element.Content) {
            //element.Content.Height = element.WindowHeight
            element.Content.LayoutWidth = width// - 2 * contentSpace


            element.Content.Content.PaddingLeft = contentSpace
            element.Content.Content.PaddingRight = contentSpace
            element.Content.Content.Width = width

            element.Content.LayoutX = LeftBarSize
            element.Content.LayoutHeight = element.Height//(element.Content.InternalHeight, element.Height)
        }
    })




    function ConfugureIcon(icon) {
        icon.Reactive = {
            AnimationProgress: 1,
            AnimationTarget: () => element.Content.ScrollYActual > 0 || icon.BarVisible ? 0 : 1
        }

        OnChanged(
            () => icon.AnimationTarget,
            (p, c) => {
                icon.AnimationProgress = AnimateTo(c ? 1 : 0, 200)
            }
        )

        icon.Y = () => icon.MarginTop
        
        icon.Width = () => lerp(collapsedIconWidth, element.SideBarsIconsSize, icon.AnimationProgress)
        icon.Height = () => lerp(collapsedIconHeight, element.SideBarsIconsSize, icon.AnimationProgress)

        icon.Radius = () => lerp(icon.Width, 0.5 * icon.Width, icon.AnimationProgress)
        icon.Visibility = () => (element.BarsCollapsed) ? 1 : 0
        icon.Depth = () => icon.BarVisible ? glassZIndex + 1 : glassZIndex - 1 

    }

    OnChanged(
        () => element.LeftSideBar && element.LeftSideBarIcon,
        (p, c) => {
            if (c) {
                let icon = element.LeftSideBarIcon
                ConfugureIcon(icon)
                icon.Reactive.BarVisible = () => (element.LeftSideBar.Width + element.LeftSideBar.X) > 0                
                
                icon.X = () => icon.MarginLeft * icon.AnimationProgress + element.LeftSideBar.X + element.LeftSideBar.Width

                icon.RadiusTopLeft = () => 0.5 * icon.Width * icon.AnimationProgress
                icon.RadiusBottomLeft = () => 0.5 * icon.Width * icon.AnimationProgress

                icon.Events.Click = () => element.SideBarOpen = -1
            }
        }
    )

    OnChanged(
        () => element.RightSideBar && element.RightSideBarIcon,
        (p, c) => {
            if (c) {
                let icon = element.RightSideBarIcon
                ConfugureIcon(icon)
                icon.Reactive.BarVisible = () => element.RightSideBar.X < element.Width

                icon.X = () => element.RightSideBar.X - icon.MarginRight * icon.AnimationProgress - element.RightSideBarIcon.Width

                icon.RadiusTopRight = () => 0.5 * icon.Width * icon.AnimationProgress
                icon.RadiusBottomRight = () => 0.5 * icon.Width * icon.AnimationProgress

                icon.Events.Click = () => element.SideBarOpen = 1
            }
        }
    )


}
function MaterialDesignIcon(element) {
    /*new Reaction(() => {
        //element.style.fill = element.ForegroundColor
    })*/

    new Reaction(() => {
        let content = element.children[0]
        content.style.fill = element.HierarchyForegroundColor
    })
}


function MaterialDesignIconBlock(element) {
    Block(element)
    MaterialDesignIcon(element)


    let width = Number(element.dataset.width)
    let height = Number(element.dataset.height)


    element.Reactive = {

        Aspect: width / height,

        VerticalPaddingSum: () => Sum(element.PaddingTop, element.PaddingBottom, 0),
        HorizontalPaddingSum: () => Sum(element.PaddingLeft, element.PaddingRight, 0),

        InternalWidth: () => First((element.Height - element.VerticalPaddingSum) * element.Aspect + element.HorizontalPaddingSum, Sum(width, element.HorizontalPaddingSum)),
        InternalHeight: () => First((element.Width - element.HorizontalPaddingSum) / element.Aspect + element.VerticalPaddingSum, Sum(height, element.VerticalPaddingSum)),
    }


    new Reaction(() => {
        let content = element.children[0]
        let w = element.Width - element.HorizontalPaddingSum
        let h = element.Height - element.VerticalPaddingSum
        if (w <= 0 || h <= 0) {
            content.style.display = "none"
            content.style.width = ""
            content.style.height = ""
        } else {
            content.style.display = ""
            content.style.left = ToCssSize(element.PaddingLeft)
            content.style.top = ToCssSize(element.PaddingTop)
            content.style.width = ToCssSize(w)
            content.style.height = ToCssSize(h)
        }
    })

    


    
}


function Thumb(element) {
    Block(element)
    element.Reactive = {
        BackgroundColor: () => element.Parent.HierarchyForegroundColor,
        
        Radius: () => Min(element.Width, element.Height) / 2,
        Depth: 1,
        Visibility: () => (window.Touch || element.ThumbSizeScale >= 1) ? 0 : element.Hover ? 0.5 : 0.25,
    }
}

function SetupPointerDrag(element, func) {
    element.Events.PointerDown = () => {
        event.stopPropagation()
        event.preventDefault()
        element.setPointerCapture(event.pointerId)

        element.Events.PointerMove = () => {
            let x = event.movementX
            let y = event.movementY
            if (x != 0 || y != 0) {
                func(x,y)
            }            
        }
        element.Events.PointerUp = () => {
            element.Events.PointerUp = undefined
            element.Events.PointerMove = undefined
        }
        return false
    }
}







function ScrollLayout(element) {
    Block(element)

    


    element.Reactive = {
        InternalWidth: () => Sum(element.Content.InternalWidth, element.MarginLeft, element.MarginRight),
        InternalHeight: () => Sum(element.Content.InternalHeight, element.TopOffset, element.BottomOffset),
        //Content: () => element.Child("Content"),

        /*MarginLeft: () => (element.PaddingLeft!=undefined) ? 0 : element.Content.MarginLeft,
        MarginTop: () => (element.PaddingTop != undefined) ? 0 : element.Content.MarginTop,
        MarginRight: () => (element.PaddingRight != undefined) ? 0 : element.Content.MarginRight,
        MarginBottom: () => (element.PaddingBottom != undefined) ? 0 : element.Content.MarginBottom,*/

        LeftOffset: () => CalcOffset(element, element.Content, "Left"),
        RightOffset: () => CalcOffset(element, element.Content, "Right"),
        TopOffset: () => CalcOffset(element, element.Content, "Top"),
        BottomOffset: () => CalcOffset(element, element.Content, "Bottom"),

        ContentAreaWidth: () => element.Width - element.LeftOffset - element.RightOffset,
        ContentAreaHeight: () => element.Height - element.TopOffset - element.BottomOffset,

        ScrollX: undefined,
        ScrollY: undefined, //Storage.Store("scroll", () => element.ScrollYActual),

        ScrollXActual: 0,
        ScrollYActual: 0,

        ScrollBarThickness: 4,
        ScrollBarMargin: 2,
        ShowScrollBars: () => !window.Touch
    }

    

    let verticalThumb = Create(element, Thumb)
    verticalThumb.Reactive = {
        ThumbTravel: () => element.Height - 2 * element.ScrollBarMargin,
        ThumbPositionScale: () => verticalThumb.ThumbTravel / element.Content.InternalHeight,
        ThumbSizeScale: () => element.ContentAreaHeight / element.Content.InternalHeight, 
        X: () => element.Width - verticalThumb.Width - element.ScrollBarMargin,
        Y: () => element.ScrollBarMargin + element.ScrollYActual * verticalThumb.ThumbPositionScale,
        Width: () => element.ScrollBarThickness,        
        Height: () => verticalThumb.ThumbTravel * verticalThumb.ThumbSizeScale,
    }
    

    let horizontalThumb = Create(element, Thumb)
    horizontalThumb.Reactive = {
        ThumbTravel: () => element.Width - 2 * element.ScrollBarMargin,
        ThumbPositionScale: () => horizontalThumb.ThumbTravel / element.Content.Width,
        ThumbSizeScale: () => element.ContentAreaWidth / element.Content.Width,        
        X: () => element.ScrollBarMargin + element.ScrollXActual * horizontalThumb.ThumbPositionScale,
        Y: () => element.Height - horizontalThumb.Height - element.ScrollBarMargin,
        Width: () => horizontalThumb.ThumbTravel * horizontalThumb.ThumbSizeScale,
        Height: () => element.ScrollBarThickness,        
    }

    /*SetupPointerDrag(verticalThumb, (x, y) => {
        scrollable.scrollTop += y / verticalThumb.ThumbPositionScale
    })

    SetupPointerDrag(horizontalThumb, (x, y) => {
        scrollable.scrollLeft += x / horizontalThumb.ThumbPositionScale
    })*/


    let scrollable = document.createElement("scrollable")
    element.appendChild(scrollable)

    scrollable.style.touchAction = "manipulation"
    scrollable.style.overflow = "auto"


    
    
    new Reaction(() => {
        scrollable.style.left = ToCssSize(element.LeftOffset)
        scrollable.style.top = ToCssSize(element.TopOffset)
        scrollable.style.width = ToCssSize(element.ContentAreaWidth)
        scrollable.style.height = ToCssSize(element.ContentAreaHeight)
    })


    scrollable.Events.Scroll = () => {
        let d = Reaction.beginDeferred()
        element.ScrollXActual = scrollable.scrollLeft
        element.ScrollYActual = scrollable.scrollTop
        d.end()
    }


    new Reaction(() => {
        scrollable.appendChild(element.Content)
        element.Content.LayoutWidth = () => Max(element.Content.InternalWidth, element.ContentAreaWidth)
        element.Content.LayoutHeight = () => Max(element.Content.InternalHeight, element.ContentAreaHeight)
    })

    new Reaction(() => {
        window.requestAnimationFrame(() => {
            scrollable.scrollTop = element.ScrollY
            scrollable.scrollLeft = element.ScrollX
        });
    })




}
function Column(element) {
    Block(element)

    element.Reactive = {
        InternalWidth: () => {

            let internalWidth = undefined
            for (let child of element.Children) {
                let left = CalcOffset(element, child, "Left")
                let right = CalcOffset(element, child, "Right")

                //let spaceLeft = Max(element.PaddingLeft, child.MarginLeft, 0)
                //let spaceRight = Max(element.PaddingRight, child.MarginRight, 0)

                let internalWidthByCurrentChild = Sum(child.InternalWidth, left + right)

                internalWidth = Max(internalWidth, internalWidthByCurrentChild)
            }
            //console.log("internalWidth", internalWidth)
            return internalWidth
        },

        //InternalHeight: undefined,
        //Height: () => element.InternalHeight,
    }


    new Reaction(() => {
        for (let child of element.Children) {
            if (child.isBlock) {

                child.LayoutX = () => CalcOffset(element, child, "Left")               

                child.LayoutWidth = () => {
                    let left = CalcOffset(element, child, "Left")
                    let right = CalcOffset(element, child, "Right")
                    return element.Width - left - right
                }
            }
        }
    })

    new Reaction(() => {
        let previousMargin
        let freeSpaceUnits
        let freeSpacePixels
        let contentHeight

        function addElement(child, assignDimensions) {
            if (child.isSpace) {
                if (assignDimensions) {
                    contentHeight += freeSpacePixels / freeSpaceUnits * child.Between
                } else {
                    freeSpaceUnits += child.Between
                }
                return true;
            }

            if (child.isBlock) {
                /*if (!child.Height) {
                    console.log("Column !child.Height", child)
                    return false

                }*/

                //console.log("child.Height", Max(child.Height, 0), child)


                let margin = Max(child.MarginTop, previousMargin)
                previousMargin = child.MarginBottom || 0


                contentHeight += margin
                if (assignDimensions) {
                    child.LayoutY = contentHeight
                }
                contentHeight += Max(child.Height, 0)


                return true
            }
            return true
        }



        previousMargin = element.PaddingTop || 0
        freeSpaceUnits = 0
        contentHeight = 0

        for (let i of element.Children) {
            if (!addElement(i, false)) {
                return
            }
        }

        //console.log("ColumnAfter Reaction", element, element.LayoutChildren)

        //Here "previousMargin" contains last-child.MarginBottom
        contentHeight += Max(previousMargin, element.PaddingBottom)
        //console.log("Vertical layout", element, contentHeight)

        previousMargin = element.PaddingTop || 0
        element.InternalHeight = contentHeight;
        if (!element.Height)
            return

        freeSpacePixels = element.Height - contentHeight;// Math.max( element.Height - contentHeight, 0)

        if (freeSpacePixels < 0) {//overflow-y: overlay;
            element.style.overflowY = "auto"
            freeSpacePixels = 0
            if (!element.innerSizeHolder) {
                element.innerSizeHolder = document.createElement('holder')
                element.innerSizeHolder.style.position = "absolute"
                element.appendChild(element.innerSizeHolder)
                element.innerSizeHolder.style.width = "1px"
            }
            element.innerSizeHolder.style.height = contentHeight + "px"
        } else {
            element.style.overflowY = ""
            if (element.innerSizeHolder) {
                element.removeChild(element.innerSizeHolder)
                element.innerSizeHolder = undefined
            }
        }

        //console.log("freeSpacePixels", freeSpacePixels)

        contentHeight = 0

        for (let i of element.Children) {
            if (!addElement(i, true)) {
                return
            }
        }
    })


}

function Paragraph(element) {

    Block(element)


    element.Reactive = {
        Selectable: true,
        InternalWidth: () => Sum(element.MaxContentWidth,element.PaddingLeft, element.PaddingRight),

        InternalHeight: undefined,

        MaxContentWidth: undefined,
        MinContentWidth: undefined,

        MaxContentHeight: undefined,
        MinContentHeight: undefined,

        PaddingLeft: () => (element.BackgroundColor != undefined) ? 10 : undefined,
        PaddingRight: () => (element.BackgroundColor != undefined) ? 10 : undefined,
        PaddingTop: () => (element.BackgroundColor != undefined) ? 8 : undefined,
        PaddingBottom: () => (element.BackgroundColor != undefined) ? 8 : undefined,

        MarginLeft: () => (element.BackgroundColor != undefined) ? 0 : 10,
        MarginRight: () => (element.BackgroundColor != undefined) ? 0 : 10,
        MarginTop: () => (element.BackgroundColor != undefined) ? 0 : 8,
        MarginBottom: () => (element.BackgroundColor != undefined) ? 0 : 8,

    }


    new Reaction(() => {

        const testFontSize = 128;

        let content = element.children[0]

        content.classList.add("inline-container")

        //content.style.position = "initial"
        content.style.fontSize = testFontSize + "px";
        content.style.width = "min-content"
        var minWidthRect = content.getBoundingClientRect()
        content.style.width = "max-content"
        var maxWidthRect = content.getBoundingClientRect()

        content.style.fontSize = ""
        content.style.width = ""


        element.MaxContentWidth = () =>  element.HierarchyFontSize / testFontSize * maxWidthRect.width
        element.MinContentWidth = () =>  element.HierarchyFontSize / testFontSize * minWidthRect.width
        element.MaxContentHeight = () => element.HierarchyFontSize / testFontSize * minWidthRect.height
        element.MinContentHeight = () => element.HierarchyFontSize / testFontSize * maxWidthRect.height

    })

    new Reaction(() => {
        let content = element.children[0]
        /*
        Left,
        Center,
        Right,
        Justify,
        JustifyIncludingLastLine
         */
        if (element.TextAlignmentHorizontal == "JustifyIncludingLastLine") {
            content.style.textAlign = "justify"
            content.style.textAlignLast = "justify"
        } else {
            content.style.textAlignLast = ""
            if (element.TextAlignmentHorizontal === undefined) {
                content.style.textAlign = ""
            } else {
                content.style.textAlign = element.TextAlignmentHorizontal.toLowerCase()
            }
        }
    })


    new Reaction(() => {
        element.style.width = ToCssSize(element.Width)
        let content = element.children[0]
        content.style.transformOrigin = ""
        content.style.transform = ""
        content.style.width = ""
        content.style.display = ""
        content.style.left = ToCssSize(element.PaddingLeft)
        content.style.top = ToCssSize(element.PaddingTop)

        let minContentWidthWithPaddings = Sum(element.MinContentWidth, element.PaddingLeft, element.PaddingRight)

        if (minContentWidthWithPaddings > element.Width) {          

            let scale = Sum(element.Width, -element.PaddingLeft, -element.PaddingRight) / element.MinContentWidth

            if (scale > 0) {
                content.style.width = "min-content"
                content.style.transformOrigin = "top left"
                content.style.transform = `scale(${scale}, ${scale})`
                element.InternalHeight = Sum(element.MaxContentHeight * scale, element.PaddingTop, element.PaddingBottom)
            } else {
                content.style.display = "none"
                element.InternalHeight = Sum(element.PaddingTop, element.PaddingBottom)
            }            
            return
        }

        let maxContentWidthWithPaddings = Sum(element.MaxContentWidth, element.PaddingLeft, element.PaddingRight)
        if (Math.abs(element.Width - maxContentWidthWithPaddings) < 0.001) {

            element.InternalHeight = Sum(element.MinContentHeight, element.PaddingTop, element.PaddingBottom) 
            content.style.width = "max-content"

            return
        }
        

        content.style.width = ToCssSize(Sum(element.Width, -element.PaddingLeft, -element.PaddingRight))

        var rect = content.getBoundingClientRect()
        element.InternalHeight = Sum(rect.height, element.PaddingTop, element.PaddingBottom)

    })

    HeightToStyle(element)
}

function ParagraphBase(element) {

    Paragraph(element)
}
function Flipper(element) {
    Block(element)
    element.isFlipper = true


    element.Reactive = {
        FlipWidth:  640,
        HorizontalSpace: 12,
        VerticalSpace: 12,
        //First: () => element.First,
        //Second: () => element.First.NextSibling
    }



    new Reaction(() => {

        if (element.Width > element.FlipWidth) {
            let left = CalcOffset(element, element.First, "Left")
            let right = CalcOffset(element, element.Second, "Right")

            let top1 = CalcOffset(element, element.First, "Top")
            let top2 = CalcOffset(element, element.Second, "Top")

            let bottom1 = CalcOffset(element, element.First, "Bottom")
            let bottom2 = CalcOffset(element, element.Second, "Bottom")

            //let spaceLeft = Max(element.PaddingLeft, element.First.MarginLeft,0)
            //let spaceRight = Max(element.PaddingRight, element.Second.MarginRight,0)
            let spaceMid = Max(
                element.First.MarginRight,
                element.Second.MarginLeft,
                element.HorizontalSpace
            )

            element.First.LayoutX = left
            element.First.LayoutWidth = (element.Width - spaceMid) * 0.5 - left

            element.Second.LayoutX = (element.Width + spaceMid) * 0.5 
            element.Second.LayoutWidth = (element.Width - spaceMid) * 0.5 - right

            element.First.LayoutY = top1
            element.Second.LayoutY = top2

            let height = Max(
                element.First.InternalHeight + top1 + bottom1,
                element.Second.InternalHeight + top2 + bottom2,
            )

            element.InternalHeight = height

            element.First.LayoutHeight = element.Height - top1 - bottom1
            element.Second.LayoutHeight = element.Height - top2 - bottom2

        } else {

            element.First.LayoutHeight = undefined
            element.Second.LayoutHeight = undefined

            let orderedChildren = [element.First, element.Second]
            let margin = First(element.PaddingTop, 0)
            
            let y = 0
            for (let i of orderedChildren) {
                i.LayoutHeight = undefined
            }

            for (let i of orderedChildren) {
                let spaceLeft = Max(element.PaddingLeft, i.MarginLeft, 0)
                let spaceRight = Max(element.PaddingRight, i.MarginRight, 0)
                let spaceTop = Max(margin, i.MarginTop, 0)

                i.LayoutX = spaceLeft
                i.LayoutWidth = element.Width - spaceLeft - spaceRight
                i.LayoutY = y + spaceTop

                y += Sum(spaceTop, i.InternalHeight)
                margin = Max(i.MarginButtom, element.VerticalSpace, 0)

            }
            
            element.InternalHeight = y + margin
        }
    })



}

function AspectBlock(element) {
    Block(element)

    let nativeAspect = element.dataset.width / element.dataset.height

    element.Reactive = {

        Aspect: element.dataset.width / element.dataset.height,
        InternalWidth: () => First(element.Height * element.Aspect, element.dataset.width),
        InternalHeight: () => First(element.Width / element.Aspect, element.dataset.height),

        Fit: "Inside",
        GravityVertical: 0,
        GravityHorizontal: 0,
    }




    new Reaction(() => {
        let content = element.children[0]

        if (element.Fit == "Stretch") {

            content.style.width = "100%"
            content.style.height = "100%"

        } else {
            let realAspect = element.Width / element.Height

            let x = 0
            let y = 0
            let contentWidth = element.Width
            let contentHeight = element.Height

            let sign = (element.Fit == "Inside") ? 1 : -1

            //if (element.Fit == "Outside") {
            if (sign * realAspect < sign * nativeAspect) {
                contentHeight = contentWidth / nativeAspect
                y = (element.Height - contentHeight) * (0.5 * sign * element.GravityVertical + 0.5)
            } else {
                contentWidth = contentHeight * nativeAspect
                x = (element.Width - contentWidth) * (0.5 * sign * element.GravityHorizontal + 0.5)
            }
            /*} else {
                if (realAspect < nativeAspect) {
                    contentHeight = contentWidth / nativeAspect
                    y = (element.Height - contentHeight) * (0.5 * element.GravityVertical + 0.5)
                } else {
                    contentWidth = contentHeight * nativeAspect
                    x = (element.Width - contentWidth) * (0.5 * element.GravityHorizontal + 0.5)
                }
            }*/


            content.style.top = ToCssSize(y)
            content.style.left = ToCssSize(x)
            content.style.width = ToCssSize(contentWidth)
            content.style.height = ToCssSize(contentHeight)

            content.style.clipPath = GetClipRect(element, x, y, contentWidth, contentHeight)

        }

    })


}

function Image(element) {
    AspectBlock(element)



    new Reaction(() => {
        let content = element.children[0]
        let thumbnail = content.querySelector("#thumbnail")
        if (thumbnail) {
            thumbnail.style.display = "block"
        }
    })

    
}


function MaterialShadow(element) {
    Hierarchical(element)

    element.isBoxShadow = true

    element.Reactive = {
        Elevation: 10

    }

    let firstBoxShadow = true

    for (let i of element.Parent.Children) {
        if (i != element) {
            if (i.isBoxShadow) {
                firstBoxShadow = false
                break;
            }  
        }
    }

    function ambientShadow(e) {
        return `0px ${0.25 * e}px ${2 * e}px ${-0.5 * e}px rgba(0, 0, 0, 0.5)`
    }
    function hardShadow(e) {
        let spread = 0.15
        let x = 0.4
        let y = 0.8
        return `${x * e}px ${y * e}px ${2*spread * e}px ${-spread*e}px rgba(0, 0, 0, 0.2)`
    }

    function shadow(e) {
        return ambientShadow(e) + "," + hardShadow(e)
    }


    if (firstBoxShadow) {
        new Reaction(() => {
            element.Parent.style.boxShadow = shadow(element.Elevation)
        })
    } else {
        new Reaction(() => {
            element.style.boxShadow = shadow(element.Elevation)
        })
        new Reaction(() => {
            element.style.width = ToCssSize(element.Parent.Width)
            element.style.height = ToCssSize(element.Parent.Height)
        })

        new Reaction(() => {
            element.style.borderTopLeftRadius = ToCssSize(element.Parent.RadiusTopLeft)
            element.style.borderTopRightRadius = ToCssSize(element.Parent.RadiusTopRight)
            element.style.borderBottomLeftRadius = ToCssSize(element.Parent.RadiusBottomLeft)
            element.style.borderBottomRightRadius = ToCssSize(element.Parent.RadiusBottomRight)
        })
    }

}

var YouTube = {
    initialize: function () {
        youtubeIFrameApiScript = document.createElement("script")
        youtubeIFrameApiScript.src = "https://www.youtube.com/iframe_api"

        let timeout = setTimeout(() => {
            document.head.removeChild(youtubeIFrameApiScript)
            youtubeIFrameApiScript.onload = undefined
            youtubeIFrameApiScript.onerror = undefined
            let d = Reaction.beginDeferred()
            YouTube.Status = "error"
            d.end()
        }, 500)

        youtubeIFrameApiScript.onload = function () {
            clearTimeout(timeout)
            YT.ready(function () {
                let d = Reaction.beginDeferred()
                YouTube.Status = "ready"
                d.end()
            })            
        }
        youtubeIFrameApiScript.onerror = function () {
            clearTimeout(timeout)
            let d = Reaction.beginDeferred()
            YouTube.Status = "error"
            d.end()
        }

        document.head.appendChild(youtubeIFrameApiScript)
        YouTube.Status = "loading"
    }
}

YouTube.Reactive = {
    Status: undefined
}


var uniqueID = 0;
function getUniqueID() {
    uniqueID++;
    return "juid" + uniqueID;
}


function Video(element) {
    Block(element)
    element.isVideo = true

    let youtubeId = element.dataset.youtubeId

    var sourcesJson = element.dataset.sources.replace(/'/g, '"');// replaceAll("'", '"');
    var sources = JSON.parse(sourcesJson)



    element.Reactive = {
        Selectable: false,

        Aspect: element.dataset.width / element.dataset.height,
        InternalWidth: () => First(element.Height * element.Aspect, element.dataset.width),
        InternalHeight: () => First(element.Width / element.Aspect, element.dataset.height),

        PreferPlatformPlayer: true,

        Controls: true,

        Loop: false,

        Play: false,
        PlayActual: () => element.Play,

        Position: 0,

        PositionActual: undefined,

        Mute: false,
        MuteActual: () => element.Mute,

        Volume: 1,
        VolumeActual: () => element.Volume,



        VideoPlayerType: undefined,//youtube, video

        Player: undefined,
        Positioner: undefined,

        PositionInitialized: false,

        SourceIndex: undefined


    }




    /*window.setInterval(() => {
        element.PositionUpdateTimer++;
    },50)*/


    var playerDestructor = undefined


    new Reaction(() => {
        if (!element.Player)
            element.PositionInitialized = false
    })


    //element.style.overflow = "hidden"



    /*
     if (!showControls) {
                iframe.style.pointerEvents = "none";
            }


     */

    new Reaction(() => {
        if (element.VideoPlayerType == "html5") {
            if (element.Player) {
                if (element.Width == undefined)
                    return;

                /*let lossFunction = (source) => {
                    return Math.abs(element.Width - source.size.x)
                }*/
                let lossFunction = (source) => {
                    let pixelWidth = window.DevicePixelRatio * element.Width
                    if (source.size.x < pixelWidth) {
                        return 8 * (pixelWidth - source.size.x)
                    }
                    return source.size.x - pixelWidth
                }

                let closestSourceLoss = lossFunction(sources[0])

                let closestSourceIndex = 0
                for (let i = 1; i < sources.length; i++) {
                    let loss = lossFunction(sources[i])
                    if (loss < closestSourceLoss) {
                        closestSourceLoss = loss
                        closestSourceIndex = i
                    }
                }
                element.SourceIndex = closestSourceIndex
            }
        }
    })

    new Reaction(() => {
        if (element.VideoPlayerType == "html5") {
            if (!element.Player)
                return

            let position = element.Player.currentTime
            element.Player.src = sources[element.SourceIndex].url
            element.Player.currentTime = position
        }
    })


    function FitOutside(child, childAspect, parentWidth, parentHeight) {

    }

    function FitInside(child, childAspect, parentWidth, parentHeight) {
        let parentAspect = parentWidth / parentHeight

        if (parentAspect > childAspect) {
            child.style.top = 0
            child.style.height = element.Height + "px"

            let calculatedWidth = element.Height * element.Aspect
            child.style.left = 0.5 * (element.Width - calculatedWidth) + "px"
            child.style.width = calculatedWidth + "px"
        } else {
            child.style.left = 0
            child.style.width = element.Width + "px"

            let calculatedHeight = element.Width / element.Aspect
            child.style.top = 0.5 * (element.Height - calculatedHeight) + "px"
            child.style.height = calculatedHeight + "px"
        }
    }
    


    new Reaction(() => {
        let positioner = element.Positioner
        if (!positioner)
            return

        FitInside(positioner, element.Aspect, element.Width, element.Height)        
    })


    function InitializeYoutubeIFrame() {
        if (playerDestructor) {
            playerDestructor()            
        }

        element.VideoPlayerType = "youtube"

        var positioner = document.createElement("youtube-iframe-positioner");
        element.appendChild(positioner);
        element.Positioner = positioner

        var iframe = document.createElement("div");
        iframe.id = getUniqueID();

        positioner.appendChild(iframe);
        iframe.style.width = "100%"
        iframe.style.height = "100%"

        let playerVars = {
            rel: 0,
            //"autoplay": autoPlay ? 1 : 0,

            //???showinfo: 0,

            controls: element.Controls ? 1 : 0,
            origin: window.location.origin
        }

        if (element.Loop) {
            playerVars.loop = 1
            playerVars.playlist = youtubeId
        }

        let volumeTimeout = undefined
        let positionTimeout = undefined

        let player = new YT.Player(iframe.id, {
            videoId: youtubeId,
            host: "http://www.youtube-nocookie.com",
            playerVars: playerVars,
            events: {
                onReady: () => {                    
                    /*if (currentPosition !== 0) {
                        player.seekTo(currentPosition, true)
                    }*/

                    element.PositionActual = () => {
                        clearTimeout(positionTimeout)

                        if (!element.Player)
                            return undefined

                        let result = element.Player.getCurrentTime()
                        if (element.PlayActual) {
                            positionTimeout = window.setTimeout(() => {
                                element.Reactive.PositionActual.makeDirty()
                            }, 50)
                        }
                        return result
                    }



                    element.VolumeActual = () => {
                        clearTimeout(volumeTimeout)

                        if (!element.Player)
                            return undefined

                        let result = element.Player.getVolume() * 0.01

                        volumeTimeout = window.setTimeout(() => {
                            element.Reactive.VolumeActual.makeDirty()
                        }, 100)
                        return result
                    }


                    element.Player = player
                    //element.PlayerReady = true
                },
                onStateChange: function (event) {
                    if (event.data == YT.PlayerState.ENDED) {
                        element.PlayActual = false
                    } else if (event.data == YT.PlayerState.PLAYING) {
                        element.PlayActual = true
                    } else if (event.data == YT.PlayerState.PAUSED) {
                        element.PlayActual = false
                    }
                }
            }
        })
        
        
        playerDestructor = function () {
            clearTimeout(volumeTimeout)
            clearTimeout(positionTimeout)
            
            playerDestructor = undefined

            player.destroy()
            element.removeChild(positioner)

            let d = Reaction.beginDeferred()
            element.Player = undefined
            d.end()
        }        
    }



    function InitializeHtml5Video() {
        element.VideoPlayerType = "html5"

        if (playerDestructor) {
            playerDestructor()
        }

        let player = document.createElement("video")
        element.appendChild(player)
        element.Positioner = player

        player.src = sources[1].url
        player.muted = true

        player.setAttribute("playsinline", "true")
        player.setAttribute("webkit-playsinline", "true")

        player.setAttribute("x5-video-player-type", "h5")
        //player.setAttribute("autoplay", "true")
        

        player.ontimeupdate = () => element.PositionActual = element.Player.currentTime

        function onPlayOrPause() {
            if (element.Play == element.Player.paused) {//anction is done by user
                window.UserInteracted = true
            }
        }

        player.onplay = () => {
            let d = Reaction.beginDeferred()
            element.PlayActual = true
            onPlayOrPause();
            d.end()
        }
        player.onpause = () => {
            let d = Reaction.beginDeferred()
            element.PlayActual = false
            onPlayOrPause()
            d.end()
        }


        element.VolumeActual = player.volume
        player.onvolumechange = () => {
            let d = Reaction.beginDeferred()
            //window.UserInteracted = true TODO
            element.VolumeActual = player.volume
            element.MuteActual = player.muted
            d.end()
        }

        player.oncanplay = () => {
            element.Player = player
        }

        
        playerDestructor = function () {
            playerDestructor = undefined

            player.ontimeupdate = undefined
            player.onpause = undefined
            player.onplay = undefined
            player.onvolumechange = undefined

            element.Player = undefined
            element.removeChild(player)            
        }
    }


    new Reaction(() => {

        if (element.PreferPlatformPlayer) {
            if (element.dataset.youtubeId !== undefined) {
                if (YouTube.Status === undefined) {
                    YouTube.initialize()
                }
                if (YouTube.Status == "ready") {
                    InitializeYoutubeIFrame()
                }
                if (YouTube.Status == "error") {
                    InitializeHtml5Video()
                }
            }
        } else {
            InitializeHtml5Video()
        }
    })



    //Position
    new Reaction(() => {
        
        if (!element.Player)
            return

        const positionTolerance = 0.05;

        if (element.VideoPlayerType == "youtube") {
            let delta = element.Player.getCurrentTime() - element.Position
            if (Math.abs(delta) > positionTolerance) {
                element.Player.seekTo(element.Position, true)
            }
        } else {
            let delta = element.Player.currentTime - element.Position
            if (Math.abs(delta) > positionTolerance) {
                element.Player.currentTime = element.Position
            }
        }
        element.PositionInitialized = true

    })

    /*if (window.history && history.pushState) { // check for history api support
        window.addEventListener('load', function () {
            // create history states
            history.pushState(-1, null); // back state
            history.pushState(0, null); // main state
            history.pushState(1, null); // forward state
            history.go(-1); // start in main state

            this.addEventListener('popstate', function (event, state) {
                // check history state and fire custom events
                if (state = event.state) {

                    event = document.createEvent('Event');
                    event.initEvent(state > 0 ? 'next' : 'previous', true, true);
                    this.dispatchEvent(event);

                    // reset state
                    history.go(-state);
                }
            }, false);
        }, false);
    }*/

    this.addEventListener('popstate', function (event, state) {
        console.log("popstate")

    })



    //Play
    new Reaction(() => {
        if (!element.Player)
            return

        if (!element.PositionInitialized)
            return     
        
        if (element.VideoPlayerType == "youtube") {
            if (element.Play) {
                console.log("Play")
                element.Player.playVideo()
            } else {
                element.Player.pauseVideo()
            }
        } else {
            if (element.SourceIndex == undefined)
                return

            window.UserInteracted //for wechat

            if (element.Play == element.Player.paused) {
                element.Play ? element.Player.play() : element.Player.pause()
            }

            //element.Player.play()
            

            
        }        
    })


    //Mute
    new Reaction(() => {
        if (element.Player) {
            if (element.VideoPlayerType == "youtube") {
                if (element.Mute) {
                    element.Player.mute()                    
                } else {
                    element.Player.unMute()
                }
            } else {
                if (element.Mute != undefined) {
                    var value = (!window.UserInteracted) || element.Mute
                    element.Player.muted = value
                }
            }
        }
    })

    //Volume
    new Reaction(() => {
        if (element.Player) {
            //console.log("element.Volume", element.Volume)
            if (element.Volume == undefined)
                return

            if (element.VideoPlayerType == "youtube") {
                element.Player.setVolume(100 * element.Volume);
            } else {
                element.Player.volume = element.Volume
            }
        }
    })


    //Loop
    new Reaction(() => {
        if (element.Player) {
            if (element.VideoPlayerType == "youtube") {

            } else {
                element.Player.loop = element.Loop
            }
        }
    })

    //Controls
    new Reaction(() => {
        if (element.Player) {
            if (element.VideoPlayerType == "youtube") {


            } else {
                element.Player.controls = element.Controls                
            }
        }
    })    

}

function Space(element) {
    element.isSpace = true
    Hierarchical(element)

    element.Reactive = {
        Before: 1,
        Between: 1,
        After: 1
    }
}


function RowMeasurer(startMargin) {
    let _this = this
    _this.margin = startMargin
    _this.currentX = 0

    _this.add = function (child) {
        let spaceLeft = First(Max(_this.margin, child.MarginLeft), 0)
        _this.currentX += spaceLeft + child.Width
        _this.margin = child.MarginRight
    }

    _this.finish = function (endMargin) {
        let spaceRight = First(Max(endMargin, _this.margin), 0)
        _this.currentX += spaceRight
    }
}

function RowBuilder(element) {
    let _this = this

    let startMargin = First(element.PaddingLeft, 0)
    let endMargin = First(element.PaddingRight, 0)
    let maxWidth = element.Width

    _this.margin = startMargin;
    _this.currentX = 0

    _this.currentLineHardY = 0
    _this.currentLineSoftY = element.PaddingTop
    _this.currentY = 0


    //_this.newLineHardY = 0
    //_this.newLineSoftY = 0

    _this.lineIsEmpty = true

    _this.currentLine = []

    _this.finalizeCurrentLine = function () {

        let margin = startMargin 
        let x = 0
        let newLineHardY = 0
        let newLineSoftY = 0
        
        let availableSpace = maxWidth - _this.currentX - Max(_this.margin, element.PaddingRight, 0)
        let spaceUnits = 0
        for (let i = 0; i < _this.currentLine.length; i++) {
            let child = _this.currentLine[i]
            if (child.isSpace) {
                switch (i) {
                    case 0:
                        spaceUnits += child.Before
                        break;
                    case _this.currentLine.length-1:
                        spaceUnits += child.After
                        break;
                    default:
                        spaceUnits += child.Between
                }

            }
        }
        
        let pixelBySpaceUnits = spaceUnits>0 ?  availableSpace / spaceUnits : 0

        for (let i = 0; i < _this.currentLine.length; i++){

            let child = _this.currentLine[i]

            if (child.isBlock) {
                let spaceLeft = First(Max(margin, child.MarginLeft), 0)

                var yA = Sum(_this.currentLineHardY, child.MarginTop)
                var yB = _this.currentLineSoftY
                var y = Max(yA, yB)

                x += spaceLeft
                child.LayoutX = x
                x += child.Width
                child.LayoutY = y
                margin = child.MarginRight

                var hardBottom = y + child.Height

                newLineHardY = Max(newLineHardY, hardBottom)
                newLineSoftY = Max(newLineSoftY, Sum(hardBottom, child.MarginBottom))

                //continue
            }
            
            if (child.isSpace) {
                switch (i) {
                    case 0:
                        x += child.Before * pixelBySpaceUnits
                        break;
                    case _this.currentLine.length - 1:
                        x += child.After * pixelBySpaceUnits
                        break;
                    default:
                        x += child.Between * pixelBySpaceUnits
                }
            }
        }

        let lastSpace = undefined
        if (_this.currentLine.length > 0) {
            let last = _this.currentLine[_this.currentLine.length - 1]
            if (last.isSpace) {
                lastSpace = last
            }
        }
        _this.currentLine = []
        if (lastSpace) {
            _this.currentLine.push(lastSpace)
        }


        _this.lineIsEmpty = true
        _this.margin = startMargin
        _this.currentX = 0
        _this.currentLineHardY = newLineHardY;
        _this.currentLineSoftY = newLineSoftY;

    }



    _this.layout = function (child) {
        let spaceLeft = First(Max(_this.margin, child.MarginLeft), 0)
        
        let spaceRight = Max(endMargin, child.MarginRight)
        if (child.isBlock) {

            if ((_this.currentX + spaceLeft + child.InternalWidth + spaceRight) > maxWidth) {
                if (_this.currentLine.length > 0) {
                    _this.finalizeCurrentLine()
                    spaceLeft = First(Max(_this.margin, child.MarginLeft), 0)
                }

                if ((spaceLeft + child.InternalWidth + spaceRight) > maxWidth) {
                    child.LayoutWidth = maxWidth - spaceLeft - spaceRight
                } else {
                    child.LayoutWidth = undefined
                }
            } else {
                child.LayoutWidth = undefined
            }
            _this.currentX += Sum(spaceLeft, child.Width)
            //console.log("_this.currentX", _this.currentX)
            _this.margin = child.MarginRight

            //_this.currentLine.push(child)

        } else {

            //_this.currentLineSpaceUnits = 0
        }
        _this.currentLine.push(child)
    }
    




}

function Row(element) {
    Block(element)

    element.isRow = true

    element.Reactive = {

        InternalWidth: () => {
            let measurer = new RowMeasurer(
                First(element.PaddingLeft, 0)
            );

            for (let child of element.children) {
                measurer.add(child)
            }
            measurer.finish();
            return measurer.currentX
        },

        //Width: () => element.InternalWidth,

        ContentWidth: undefined,
        ContentHeight: undefined,

        /*Width: () => First(
            element.LayoutWidth,
            Sum(
                element.ContentWidth,
                element.PaddingLeft,
                element.PaddingRight
            )
        ),*/
        //Height: 150//() => Sum(element.ContentHeight, element.PaddingTop, element.PaddingButtom),
    }

    new Reaction(() => {

        /*let contentWidth = undefined

        let line = []
        let lineContentWidth = 0
        let lineGrowUnits = 0
        let previousMargin = First(element.PaddingLeft,0)*/

        let builder = new RowBuilder(element);

        for (let child of element.Children) {
            builder.layout(child)

        }
        builder.finalizeCurrentLine()

        var hA = Sum(builder.currentLineHardY, element.PaddingBottom)
        var hB = builder.currentLineSoftY

        element.InternalHeight = Max(hA, hB)


    })

}
</script><style>html {
    display: initial;
    position: initial;
    overscroll-behavior-x: none;
    overflow: hidden;
    overflow-x: hidden;
    overflow-y: hidden;
   
}

.js {
    //display: none;
    visibility: hidden;
    position: absolute;
    overflow: hidden;
    overflow-x: hidden;
    overflow-y: hidden;
    white-space: normal;
    line-height: 1.5;
    touch-action: none;
    margin: 0;
}



:not(.js) material-design-icon-block>svg {
    width: 24px
}





.js * {
    scrollbar-width: none;
}
.js *::-webkit-scrollbar {
    display: none;
}

head {
    display: none;
}



.js * {
    tab-size: 4;
    touch-action: inherit;
    display: block;
    overflow-x: visible;
    overflow-y: visible;
    //z-index: inherit;
    position: absolute;
    //position: inherit;
    margin: 0;
    visibility: inherit;
    margin-block-start: 0;
    margin-block-end: 0;
    margin-inline-start: 0;
    margin-inline-end: 0;
    line-height: inherit;
    text-decoration-line: inherit;
    color: inherit;
    justify-content: inherit;
    align-content: inherit;
    text-align: inherit;
    box-sizing: border-box;
    word-break: keep-all;
    //cursor: inherit;
    //word-wrap: break-word;
    //overflow: clip;
    //overflow: hidden;
    white-space: inherit;
}

.js a * {
    //text-decoration-line: underline;
}



    /** {
        outline: 0.1px solid #f00 !important;
    }*/





.inline-container {
    white-space: break-spaces;
}

.inline-container * {
    
    position: static;
    display: inline;
}

.inline-container a * {
    text-decoration-line: underline;
}

/*body.js paragraph>p * {
    
}*/

</style><style>@font-face {font-family: 'Roboto';font-weight: 700;font-style: normal;src: url(data:application/font-woff2;charset=utf-8;base64,d09GMgABAAAAAAscABIAAAAAFUAAAAq9AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGigbgUYcgW4GYABsCEgJgzwRDAqWdJRQCyoAEiABNgIkA04EIAWCfgcgDIIpG7YSyMSnp017fw3bDQsl0mxlCa2jqdOTCiSTpg5JIeLEBBLvteTOaU/UP3s58Zx5LcmJO5f7fdpsjlESuRMK0KLy/28e5xigjMISgZFl1alRN1XS1sA8e9XMrFBYcOB7nUHAYB76PIvQgYsD6X+AdQQcpB4aNzbCixPABYq2hpHfOBLvhGtLPNbh2lnf350OjoJ0I2nXEYt3Q39gK84x7UigB4MNkc56K7aDg4B5RmZyo/1sZIP/Y4GnAUaYuJG9YKiMxdlA9OQ6QkAKyUBC12KY8izpK3Hgm7p7uuBvjtc3orB7oCsOZ2/3QBcW9W+SVMZCNoWeoATuOFGlax22YAnyixSLYGeCCqJgK7IKAqGyvSYrCE5ghziRgQxL1AIh86NHDCtmWUBGletZ7lbmsSwM4q/gVwBk/q6cPYzmkkhhcqwsCSzW1dKBphrlxTt2FA9rM/8J+B9Bm3VXMFBBrh3A+XkKFWqRYnzccZtyCDsOkXZWyGAR43YrsBlb0YYeJDCQyTBPKnQadvxx5qPMocxTmYczV2euylyeuawiR80fdRm+wk34H9tRR3y4C8/hGPbCJe4L/V8HG3MlVNYOE+eHjTsbMk9hE/KQTW6BRZhElvBBWr8iCmcpNeyMpAk5J/oQyZxGA3PTBra2xkWJU1WDbQFK6lyUcVKyzO6irFMtouzCot0RR1RNqamSppRapLbWN1FuYZHaWt+0O+KIpaIelSIUaVMpwhE73RBV2lR6bB+LRv0uytEw4FJTUWSp7bEN2vWmn/9clHeWvj+7aGdkV4QmAwrdEIgqdrsapJM7I3QyoNijURcV1OukqsGT2vIUJbpGYZmL6hNfIRShGxSKaCpFXMdhp8lUSkk5or1QJnf5EIEVYsMAyi4MPkSSOz3Lkw67ggdy2B32qGKPBlzU4CwNRYIBxa69iosanbQg6KImJ3UEXVR0pheTM9VUKPJwh3/+xof0ODMceRgF7Je9UYU6QhGqnvmQjBlm8HElJ91w5kMqKiJpBwLKw3CwXwairibdUQ8mk4G5SXBb7+pLAOQC5HyACd64mmwA/0fnFRYLMQc91IxpxrE3zF86V+BMEjfPmiUusuQtxL/FkjVmHh5rbdd3VJnbSUfWLJm0zMyQ8Wlj6hjE8ZkZ04EpJI+Fm8xjpgNe9KPLTk0h+aEx9TGRklO+j2I0jh37VDz4OUvG3/nEdOCzMnE6ekYYw6vvaTRDHpMk0SA1j7O9cWq6JcyIY5Kwp0VqahMlEYHGymZMB8ryOZHnmBWu3hVwoiFgh6kyzsFrpRn6WVlZ8tODn7P1cqDITonx6fKPCZ9EUfHy5NRUmd7emJqeJtJUNK3nzK2cl7jkJfbwkl4cyiItRzNSnToEo5TXDYelMdMBMv66MfWiR1KYTjoxCSRH96TcaI4Z4Zb/wC55Fjx9lo1VgddZTg4O/mAa+uR6llSfSarZnSWfPz/9W11b1dXF9fXdlQ29p3cXnLbvnS/2XvjRnzPPdfZ8cMZFW6rilXkXRq7obuuqjLTWV4V6Kkrs8dGJd2OnfcG/+3TTyK0NztHlw/cOP53/1Vdv2z573L57tKWipb+z4u0fLz9/x/mfyV+vlZC3YbgkeuTCE613PPDvCin3F6fx4On7UpdcNE0+6v72nLeuOHDmPsOpxXf/eNJPt4OnzqXXFfgLCnM3lodKt+wJbdwUCV0QCZ34R7qlZYsdAuyhNcW2QOXpT982uDV4XQEEFMzN/dSvH44ffPbwtpv6bjpK73z19fsKtKricOXJvjF8bk/XlISiY6tj/9n9w7kX+fV7E+c9c9etL5EXH7VPVO3YXT16XMs/dn9446Lrx/758qwr3rGZzJ+Rkr+yncdyljOq7orEDZ1tA9elLx24uaM9cVPwoWWrWo9L5I7v/OO87yefev33p660n7BjZ1nJjo0rvBX+mWUl+Z+G3rjovwdeOvNI3dBtDVZ2a9uuaCh8QvXvXe3jj9/zwAtk8jn7o7dfceHq2P8Ffjk8cUVnah56vaHccG3h3Z7X+++4+oyLrksOFRUnOsovjNdWWmx9u4cijrN8y+6Z+1rzbaOnnH/HYMfQ6b6Ll5zb9sC+i86589T46wWbvSuPCziqRlB14f2dqXno9YZyw7WFrLaZPGXmX8sId4FMRngmIN7XKwK4Ev5ZbMh8y63gnwVFMEIZj5Jm8k6IngFMIQ7WOAYW6zqN3xrqDPSN1PiuJl4YShdjZJr1rtenWfIVW6AJllAtt0znEWpcHrG/qfwa1Rjk2Ras5UCLnDb42IuwGOT08Po03dJldMFsbAYFlHyNmDlvXko8Ez1kP2GqJ/aTcwnTN/EB+YEw1VqGkL6JdaSEMNXULKd1YpKMiXaU04s97LIXk3JtvmL2IUqwgkyvTwkwGZuABfZnqEmm5kPUJKetkU+mrJyefV5M5xyiAZwxx6pCjzVpiCrXdGZZhRN1MsWhUgvNhtVwytIhKnnSgiArE2GUD/r19DaOozKE+WkHPZOhCVuJAgs3Xz7PHl6fxs2bXzksHyS2oJurU3E+Gxd2BrPWnyVWqJnOlKHx2xOpTk7LOajm9Y9AE62zRI7lwySQwGoPY2wGHVbLXDGnhVqcSi1YzR3Kt3FVXp22SHIwJ6dzKZQoixZLNTan5ZTZM4o+w6QXpOgRzWzozMg0+5A235sowRw9vD7NaLFSBsFYAGlhqUxBNpCpdDJl5LRR2j3Q583uXqwQibxjOodpuxY5MDAT82y9j70J5iybGS7zFi5iykmAXPNc2SxXUvdamzdPO0RI9QPXEUomCdv3wAayk9QRtk87j5DqCS/ZQJg4leS0IKrQIJFZOnWYHd9U3o1qVodprzhySe6Wz2MyOq/1SjUW5sjJyM7J0u5Yc3aKDcQJ9RDWcIvahG3L9E1o192+dq8S7yR8uYzqb9fKFVI9sUoJKkx1psVPrFvnGfQcw/MCz/CMnud5/rkwi+cDLs04rKtzzAdrzcf9pp/9XtsOePZHi3t31ymye/pv739ThjP0CRAY3qwI+cu6zv9FwJD62/v/KsMZnzUvP4s9iCbyP8BdiiLuUmzgj0M5V4aTmfno4orQo9vuE757CW4Mbdzp2MTNxVpuFK3MP1jD/AMv87dG/sakWdjwAdb1XORgO3hBPOtNtKAQApmvR/OHWhpn6BXV4JGTN4GIe/AFO+kWeLPIwXnBOW8ei9DuLSAHYTXLxs/6y/ejH73wwwMPhhZ1btSjt/cyjWhFDG70II4WeNCJNjQihm4kejpc3IOtKMFmBLEdIVzchUK44cVu9KAB0J/nwiZcrhNNKEcMcSQ+Lnn3Z+VAN3xYgTVYT4B37ppkJqq0GxOgbsbAXowgjja0ZEFiUOeDimJDh7oWdCLWu1gJutEIN1Rs1PI6ofakBDxBYFZQte6DiKEJ7t8QaZl2Y6L5K1JxOcVyaMTELMeDxLdkfk4W9MsfZAJ+p2o9pLDOANz5Q1V+RwB+sK509dwAwsL5eRZTg27T6mXzIgfQ+z0FeeYiw2qnHsBYWepfNtuf6Z/XrosHB0ETTbrlFO+Ut9a8WSShUZkktJ0y6deSa9IbZEA70UYSWi3dTzz2/doO2kPPpffSTOZ8m0EH6IAOfsx5JKH15A9o+w/aDyDz7fu1WnoufYNmtBOjmHnytR6YedTyE1WSAAAA) format('woff2');}
@font-face {font-family: 'Roboto';font-weight: 300;font-style: normal;src: url(data:application/font-woff2;charset=utf-8;base64,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) format('woff2');}
@font-face {font-family: 'Roboto';font-weight: 500;font-style: normal;src: url(data:application/font-woff2;charset=utf-8;base64,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) format('woff2');}
@font-face {font-family: 'Roboto';font-weight: 400;font-style: normal;src: url(data:application/font-woff2;charset=utf-8;base64,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) format('woff2');}
</style></head><body style="font-family:Roboto;font-weight:400;"><script>{let element = Constructor(PageSideMenus);element.Reactive={ContentWidth:800,SideBarsIconsSize:48,FontSize:16}}</script><material-design-icon-block data-property="LeftSideBarIcon" data-width="24" data-height="24" style="font-family:;"><script>{let element = Constructor(MaterialDesignIcon,MaterialDesignIconBlock);element.Reactive={BackgroundColor:new Color(0.42745098039215684,0.34901960784313724,0.47843137254901963),PaddingLeft:8,PaddingRight:8,PaddingTop:8,PaddingBottom:8,MarginLeft:8,MarginRight:8,MarginTop:8,MarginBottom:8}}</script><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" />
</svg><script>Pop()</script></material-design-icon-block><scroll-layout data-property="LeftSideBar" style="font-family:;"><script>{let element = Constructor(ScrollLayout);}</script><column data-property="Content" style="font-family:;"><script>{let element = Constructor(Column);element.Reactive={BackgroundColor:new Color(0.25,0.25,0.25)}}</script><a href="ru" target="_self" style="display:contents;"><paragraph data-child style="font-family:;"><script>{let element = Constructor(Paragraph);element.Reactive={MarginLeft:0,MarginRight:0,MarginTop:0,MarginBottom:0,PaddingTop:10,PaddingBottom:10,PaddingLeft:20,PaddingRight:20}}</script><p>Code
</p><block data-child style="font-family:;"><script>{let element = Constructor(Block);element.Reactive={BackgroundColor:(e) => e.ParentBlock.HierarchyForegroundColor,Visibility:(e) => (e.ParentBlock.Hover?0.1:0),Depth:-1,Y:(e) => First(e.MarginTop,0),Height:(e) => Sum(e.ParentBlock.Height,(-e.MarginTop),(-e.MarginLeft)),X:(e) => First(e.MarginLeft,0),Width:(e) => Sum(e.ParentBlock.Width,(-e.MarginLeft),(-e.MarginRight))}}</script><script>Pop()</script></block><script>Pop()</script></paragraph></a><a href="../ImageComponent/ru" target="_self" style="display:contents;"><paragraph data-child style="font-family:;"><script>{let element = Constructor(Paragraph);element.Reactive={MarginLeft:0,MarginRight:0,MarginTop:0,MarginBottom:0,PaddingTop:10,PaddingBottom:10,PaddingLeft:20,PaddingRight:20}}</script><p>Image
</p><block data-child style="font-family:;"><script>{let element = Constructor(Block);element.Reactive={BackgroundColor:(e) => e.ParentBlock.HierarchyForegroundColor,Visibility:(e) => (e.ParentBlock.Hover?0.1:0),Depth:-1,Y:(e) => First(e.MarginTop,0),Height:(e) => Sum(e.ParentBlock.Height,(-e.MarginTop),(-e.MarginLeft)),X:(e) => First(e.MarginLeft,0),Width:(e) => Sum(e.ParentBlock.Width,(-e.MarginLeft),(-e.MarginRight))}}</script><script>Pop()</script></block><script>Pop()</script></paragraph></a><a href="../MaterialDesignIconsComponent/ru" target="_self" style="display:contents;"><paragraph data-child style="font-family:;"><script>{let element = Constructor(Paragraph);element.Reactive={MarginLeft:0,MarginRight:0,MarginTop:0,MarginBottom:0,PaddingTop:10,PaddingBottom:10,PaddingLeft:20,PaddingRight:20}}</script><p>Material Design Icons
</p><block data-child style="font-family:;"><script>{let element = Constructor(Block);element.Reactive={BackgroundColor:(e) => e.ParentBlock.HierarchyForegroundColor,Visibility:(e) => (e.ParentBlock.Hover?0.1:0),Depth:-1,Y:(e) => First(e.MarginTop,0),Height:(e) => Sum(e.ParentBlock.Height,(-e.MarginTop),(-e.MarginLeft)),X:(e) => First(e.MarginLeft,0),Width:(e) => Sum(e.ParentBlock.Width,(-e.MarginLeft),(-e.MarginRight))}}</script><script>Pop()</script></block><script>Pop()</script></paragraph></a><a href="../ParagraphComponent/ru" target="_self" style="display:contents;"><paragraph data-child style="font-family:;"><script>{let element = Constructor(Paragraph);element.Reactive={MarginLeft:0,MarginRight:0,MarginTop:0,MarginBottom:0,PaddingTop:10,PaddingBottom:10,PaddingLeft:20,PaddingRight:20}}</script><p>Paragraph
</p><block data-child style="font-family:;"><script>{let element = Constructor(Block);element.Reactive={BackgroundColor:(e) => e.ParentBlock.HierarchyForegroundColor,Visibility:(e) => (e.ParentBlock.Hover?0.1:0),Depth:-1,Y:(e) => First(e.MarginTop,0),Height:(e) => Sum(e.ParentBlock.Height,(-e.MarginTop),(-e.MarginLeft)),X:(e) => First(e.MarginLeft,0),Width:(e) => Sum(e.ParentBlock.Width,(-e.MarginLeft),(-e.MarginRight))}}</script><script>Pop()</script></block><script>Pop()</script></paragraph></a><a href="../ScrollLayoutComponent/ru" target="_self" style="display:contents;"><paragraph data-child style="font-family:;"><script>{let element = Constructor(Paragraph);element.Reactive={MarginLeft:0,MarginRight:0,MarginTop:0,MarginBottom:0,PaddingTop:10,PaddingBottom:10,PaddingLeft:20,PaddingRight:20}}</script><p>Scroll Layout
</p><block data-child style="font-family:;"><script>{let element = Constructor(Block);element.Reactive={BackgroundColor:(e) => e.ParentBlock.HierarchyForegroundColor,Visibility:(e) => (e.ParentBlock.Hover?0.1:0),Depth:-1,Y:(e) => First(e.MarginTop,0),Height:(e) => Sum(e.ParentBlock.Height,(-e.MarginTop),(-e.MarginLeft)),X:(e) => First(e.MarginLeft,0),Width:(e) => Sum(e.ParentBlock.Width,(-e.MarginLeft),(-e.MarginRight))}}</script><script>Pop()</script></block><script>Pop()</script></paragraph></a><a href="../VideoPlayer/ru" target="_self" style="display:contents;"><paragraph data-child style="font-family:;"><script>{let element = Constructor(Paragraph);element.Reactive={MarginLeft:0,MarginRight:0,MarginTop:0,MarginBottom:0,PaddingTop:10,PaddingBottom:10,PaddingLeft:20,PaddingRight:20}}</script><p>Video Player
</p><block data-child style="font-family:;"><script>{let element = Constructor(Block);element.Reactive={BackgroundColor:(e) => e.ParentBlock.HierarchyForegroundColor,Visibility:(e) => (e.ParentBlock.Hover?0.1:0),Depth:-1,Y:(e) => First(e.MarginTop,0),Height:(e) => Sum(e.ParentBlock.Height,(-e.MarginTop),(-e.MarginLeft)),X:(e) => First(e.MarginLeft,0),Width:(e) => Sum(e.ParentBlock.Width,(-e.MarginLeft),(-e.MarginRight))}}</script><script>Pop()</script></block><script>Pop()</script></paragraph></a><script>Pop()</script></column><script>Pop()</script></scroll-layout><material-design-icon-block data-property="RightSideBarIcon" data-width="24" data-height="24" style="font-family:;"><script>{let element = Constructor(MaterialDesignIcon,MaterialDesignIconBlock);element.Reactive={BackgroundColor:new Color(0.47843137254901963,0.34901960784313724,0.1411764705882353),PaddingLeft:8,PaddingRight:8,PaddingTop:8,PaddingBottom:8,MarginLeft:8,MarginRight:8,MarginTop:8,MarginBottom:8}}</script><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
  <path d="M12.87,15.07L10.33,12.56L10.36,12.53C12.1,10.59 13.34,8.36 14.07,6H17V4H10V2H8V4H1V6H12.17C11.5,7.92 10.44,9.75 9,11.35C8.07,10.32 7.3,9.19 6.69,8H4.69C5.42,9.63 6.42,11.17 7.67,12.56L2.58,17.58L4,19L9,14L12.11,17.11L12.87,15.07M18.5,10H16.5L12,22H14L15.12,19H19.87L21,22H23L18.5,10M15.88,17L17.5,12.67L19.12,17H15.88Z" />
</svg><script>Pop()</script></material-design-icon-block><column data-property="RightSideBar" style="font-family:;"><script>{let element = Constructor(Column);element.Reactive={BackgroundColor:new Color(0.47843137254901963,0.34901960784313724,0.1411764705882353)}}</script><a href="en" target="_self" style="display:contents;"><paragraph data-child style="font-family:;"><script>{let element = Constructor(Paragraph);element.Reactive={MarginLeft:0,MarginRight:0,MarginTop:0,MarginBottom:0,PaddingTop:10,PaddingBottom:10,PaddingLeft:20,PaddingRight:20}}</script><p>En
</p><block data-child style="font-family:;"><script>{let element = Constructor(Block);element.Reactive={BackgroundColor:(e) => e.ParentBlock.HierarchyForegroundColor,Visibility:(e) => (e.ParentBlock.Hover?0.1:0),Depth:-1,Y:(e) => First(e.MarginTop,0),Height:(e) => Sum(e.ParentBlock.Height,(-e.MarginTop),(-e.MarginLeft)),X:(e) => First(e.MarginLeft,0),Width:(e) => Sum(e.ParentBlock.Width,(-e.MarginLeft),(-e.MarginRight))}}</script><script>Pop()</script></block><script>Pop()</script></paragraph></a><a href="ru" target="_self" style="display:contents;"><paragraph data-child style="font-family:;"><script>{let element = Constructor(Paragraph);element.Reactive={MarginLeft:0,MarginRight:0,MarginTop:0,MarginBottom:0,PaddingTop:10,PaddingBottom:10,PaddingLeft:20,PaddingRight:20}}</script><p>Ru
</p><block data-child style="font-family:;"><script>{let element = Constructor(Block);element.Reactive={BackgroundColor:(e) => e.ParentBlock.HierarchyForegroundColor,Visibility:(e) => (e.ParentBlock.Hover?0.1:0),Depth:-1,Y:(e) => First(e.MarginTop,0),Height:(e) => Sum(e.ParentBlock.Height,(-e.MarginTop),(-e.MarginLeft)),X:(e) => First(e.MarginLeft,0),Width:(e) => Sum(e.ParentBlock.Width,(-e.MarginLeft),(-e.MarginRight))}}</script><script>Pop()</script></block><script>Pop()</script></paragraph></a><script>Pop()</script></column><scroll-layout data-property="Content" style="font-family:;"><script>{let element = Constructor(ScrollLayout);}</script><column data-property="Content" style="font-family:;"><script>{let element = Constructor(Column);}</script><paragraph data-child data-property="TopBar" style="font-family:;font-weight:200;"><script>{let element = Constructor(Paragraph);element.Reactive={Height:(e) => Max(e.Root.SideBarsIconsSize,e.InternalHeight),TextAlignmentHorizontal:"Center",MarginTop:0,MarginBottom:0,FontSize:(e) => e.Root.SideBarsIconsSize}}</script><p>Code
</p><script>Pop()</script></paragraph><paragraph data-child data-property="Description" style="font-family:;"><script>{let element = Constructor(Paragraph);}</script><p>CodeBlock and CodeInline component.
</p><script>Pop()</script></paragraph><block data-child style="font-family:;"><script>{let element = Constructor(Block);element.Reactive={Height:1,BackgroundColor:new Color(0.5019607843137255,0.5019607843137255,0.5019607843137255),MarginBottom:20}}</script><script>Pop()</script></block><a href="../ImageComponent/ru" target="_self" style="display:contents;"><flipper data-child style="font-family:;"><script>{let element = Constructor(Flipper);element.Reactive={MarginLeft:10,MarginRight:10,MarginTop:10,MarginBottom:10,Radius:10,FlipWidth:500}}</script><image-block data-property="First" data-width="1920" data-height="1330" style="font-family:;"><script>{let element = Constructor(Image);element.Reactive={ClipByParent:true}}</script><content><svg id="thumbnail" width="100%" height="100%" viewBox="0 0 32 22" preserveAspectRatio="none" style="overflow:hidden;display:none;"><use href="#7F76A4FA6725CA56"></use><use href="#7F76A4FA6725CA56" filter="url(#A65402ECAD179F53)"></use><g filter="url(#A8D38B2D8722AFE8)"><use href="#7F76A4FA6725CA56"></use><use href="#7F76A4FA6725CA56" filter="url(#A65402ECAD179F53)"></use></g></svg><img width="100%" height="100%" src="../../Assets/4118C156A3C0103152F54A524DB8EC50.jpg"></content><script>Pop()</script></image-block><column data-property="Second" style="font-family:;"><script>{let element = Constructor(Column);}</script><paragraph data-child style="font-family:;font-weight:500;"><script>{let element = Constructor(Paragraph);element.Reactive={FontSize:34}}</script><p>Image
</p><script>Pop()</script></paragraph><paragraph data-child style="font-family:;"><script>{let element = Constructor(Paragraph);}</script><p>StaticSharp Image component.
</p><script>Pop()</script></paragraph><script>Pop()</script></column><material-shadow data-child><script>{let element = Constructor(MaterialShadow);element.Reactive={Elevation:3}}</script><script>Pop()</script></material-shadow><script>Pop()</script></flipper></a><a href="../VideoPlayer/ru" target="_self" style="display:contents;"><flipper data-child style="font-family:;"><script>{let element = Constructor(Flipper);element.Reactive={MarginLeft:10,MarginRight:10,MarginTop:10,MarginBottom:10,Radius:10,FlipWidth:500}}</script><player data-property="First" data-youtube-id="T4TEdzSLyi0" data-width="1280" data-height="720" data-sources="[{'size':{'x':640,'y':360},'url':'../../Assets/C6CC5F43B642138BAB2E5DDA9BE25D89.mp4'},{'size':{'x':1280,'y':720},'url':'../../Assets/FA86418F339E376894229D4942E71588.mp4'}]" style="font-family:;"><script>{let element = Constructor(Video);element.Reactive={Play:true,Mute:true,Loop:true,Controls:false,PreferPlatformPlayer:false,ClipByParent:true}}</script><script>Pop()</script></player><column data-property="Second" style="font-family:;"><script>{let element = Constructor(Column);}</script><paragraph data-child style="font-family:;font-weight:500;"><script>{let element = Constructor(Paragraph);element.Reactive={FontSize:34}}</script><p>Video Player
</p><script>Pop()</script></paragraph><paragraph data-child style="font-family:;"><script>{let element = Constructor(Paragraph);}</script><p>StaticSharp VideoPlayer component.
</p><script>Pop()</script></paragraph><script>Pop()</script></column><material-shadow data-child><script>{let element = Constructor(MaterialShadow);element.Reactive={Elevation:3}}</script><script>Pop()</script></material-shadow><script>Pop()</script></flipper></a><block data-child style="font-family:;"><script>{let element = Constructor(Block);element.Reactive={Height:50,MarginLeft:10,MarginRight:10,MarginTop:10,MarginBottom:10,Radius:3,BackgroundColor:new Color(1,1,1)}}</script><material-shadow data-child><script>{let element = Constructor(MaterialShadow);element.Reactive={Elevation:(e) => (e.ParentBlock.Hover?0.5:1)}}</script><script>Pop()</script></material-shadow><script>Pop()</script></block><block data-child style="font-family:;"><script>{let element = Constructor(Block);element.Reactive={Height:50,MarginLeft:10,MarginRight:10,MarginTop:10,MarginBottom:10,Radius:3,BackgroundColor:new Color(1,1,1)}}</script><material-shadow data-child><script>{let element = Constructor(MaterialShadow);element.Reactive={Elevation:(e) => (e.ParentBlock.Hover?1:2)}}</script><script>Pop()</script></material-shadow><script>Pop()</script></block><block data-child style="font-family:;"><script>{let element = Constructor(Block);element.Reactive={Height:50,MarginLeft:10,MarginRight:10,MarginTop:10,MarginBottom:10,Radius:3,BackgroundColor:new Color(1,1,1)}}</script><material-shadow data-child><script>{let element = Constructor(MaterialShadow);element.Reactive={Elevation:(e) => (e.ParentBlock.Hover?1.5:3)}}</script><script>Pop()</script></material-shadow><script>Pop()</script></block><block data-child style="font-family:;"><script>{let element = Constructor(Block);element.Reactive={Height:50,MarginLeft:10,MarginRight:10,MarginTop:10,MarginBottom:10,Radius:3,BackgroundColor:new Color(1,1,1)}}</script><material-shadow data-child><script>{let element = Constructor(MaterialShadow);element.Reactive={Elevation:(e) => (e.ParentBlock.Hover?2:4)}}</script><script>Pop()</script></material-shadow><script>Pop()</script></block><block data-child style="font-family:;"><script>{let element = Constructor(Block);element.Reactive={Height:50,MarginLeft:10,MarginRight:10,MarginTop:10,MarginBottom:10,Radius:3,BackgroundColor:new Color(1,1,1)}}</script><material-shadow data-child><script>{let element = Constructor(MaterialShadow);element.Reactive={Elevation:(e) => (e.ParentBlock.Hover?2.5:5)}}</script><script>Pop()</script></material-shadow><script>Pop()</script></block><block data-child style="font-family:;"><script>{let element = Constructor(Block);element.Reactive={Height:50,MarginLeft:10,MarginRight:10,MarginTop:10,MarginBottom:10,Radius:3,BackgroundColor:new Color(1,1,1)}}</script><material-shadow data-child><script>{let element = Constructor(MaterialShadow);element.Reactive={Elevation:(e) => (e.ParentBlock.Hover?3:6)}}</script><script>Pop()</script></material-shadow><script>Pop()</script></block><block data-child style="font-family:;"><script>{let element = Constructor(Block);element.Reactive={Height:50,MarginLeft:10,MarginRight:10,MarginTop:10,MarginBottom:10,Radius:3,BackgroundColor:new Color(1,1,1)}}</script><material-shadow data-child><script>{let element = Constructor(MaterialShadow);element.Reactive={Elevation:(e) => (e.ParentBlock.Hover?3.5:7)}}</script><script>Pop()</script></material-shadow><script>Pop()</script></block><block data-child style="font-family:;"><script>{let element = Constructor(Block);element.Reactive={Height:50,MarginLeft:10,MarginRight:10,MarginTop:10,MarginBottom:10,Radius:3,BackgroundColor:new Color(1,1,1)}}</script><material-shadow data-child><script>{let element = Constructor(MaterialShadow);element.Reactive={Elevation:(e) => (e.ParentBlock.Hover?4:8)}}</script><script>Pop()</script></material-shadow><script>Pop()</script></block><block data-child style="font-family:;"><script>{let element = Constructor(Block);element.Reactive={Height:50,MarginLeft:10,MarginRight:10,MarginTop:10,MarginBottom:10,Radius:3,BackgroundColor:new Color(1,1,1)}}</script><material-shadow data-child><script>{let element = Constructor(MaterialShadow);element.Reactive={Elevation:(e) => (e.ParentBlock.Hover?4.5:9)}}</script><script>Pop()</script></material-shadow><script>Pop()</script></block><block data-child style="font-family:;"><script>{let element = Constructor(Block);element.Reactive={Height:50,MarginLeft:10,MarginRight:10,MarginTop:10,MarginBottom:10,Radius:3,BackgroundColor:new Color(1,1,1)}}</script><material-shadow data-child><script>{let element = Constructor(MaterialShadow);element.Reactive={Elevation:(e) => (e.ParentBlock.Hover?5:10)}}</script><script>Pop()</script></material-shadow><script>Pop()</script></block><ws data-child><script>{let element = Constructor(Space);}</script><script>Pop()</script></ws><row data-child data-property="Footer" style="font-family:;"><script>{let element = Constructor(Row);element.Reactive={BackgroundColor:new Color(0.20784313725490197,0.3137254901960784,0.4392156862745098),PaddingTop:20,PaddingBottom:20,X:(e) => First(e.MarginLeft,0),Width:(e) => Sum(e.ParentBlock.Width,(-e.MarginLeft),(-e.MarginRight)),PaddingLeft:(e) => e.ParentBlock.PaddingLeft,PaddingRight:(e) => e.ParentBlock.PaddingRight}}</script><ws data-child><script>{let element = Constructor(Space);element.Reactive={Before:1.401298464324817E-45,After:1.401298464324817E-45}}</script><script>Pop()</script></ws><column data-child style="font-family:;"><script>{let element = Constructor(Column);element.Reactive={MarginLeft:10,MarginRight:10,MarginTop:20,MarginBottom:20}}</script><paragraph data-child style="font-family:;font-weight:700;"><script>{let element = Constructor(Paragraph);element.Reactive={FontSize:18,MarginTop:0}}</script><p>Links
</p><script>Pop()</script></paragraph><paragraph data-child style="font-family:;"><script>{let element = Constructor(Paragraph);element.Reactive={MarginBottom:0}}</script><p>тут будут ссылки
</p><script>Pop()</script></paragraph><script>Pop()</script></column><ws data-child><script>{let element = Constructor(Space);element.Reactive={Before:1.401298464324817E-45,After:1.401298464324817E-45}}</script><script>Pop()</script></ws><column data-child style="font-family:;"><script>{let element = Constructor(Column);element.Reactive={MarginLeft:10,MarginRight:10,MarginTop:20,MarginBottom:20}}</script><paragraph data-child style="font-family:;font-weight:700;"><script>{let element = Constructor(Paragraph);element.Reactive={FontSize:18,MarginTop:0}}</script><p>Column 2
</p><script>Pop()</script></paragraph><paragraph data-child style="font-family:;"><script>{let element = Constructor(Paragraph);element.Reactive={MarginBottom:0}}</script><p>тут будут еще ссылки
</p><script>Pop()</script></paragraph><script>Pop()</script></column><ws data-child><script>{let element = Constructor(Space);element.Reactive={Before:1.401298464324817E-45,After:1.401298464324817E-45}}</script><script>Pop()</script></ws><column data-child style="font-family:;"><script>{let element = Constructor(Column);element.Reactive={MarginLeft:10,MarginRight:10,MarginTop:20,MarginBottom:20}}</script><paragraph data-child style="font-family:;font-weight:700;"><script>{let element = Constructor(Paragraph);element.Reactive={FontSize:18,MarginTop:0}}</script><p>Column 3
</p><script>Pop()</script></paragraph><paragraph data-child style="font-family:;"><script>{let element = Constructor(Paragraph);}</script><p>и тут будут ссылки
</p><script>Pop()</script></paragraph><paragraph data-child style="font-family:;"><script>{let element = Constructor(Paragraph);}</script><p>line 2
</p><script>Pop()</script></paragraph><paragraph data-child style="font-family:;"><script>{let element = Constructor(Paragraph);element.Reactive={MarginBottom:0}}</script><p>line 3
</p><script>Pop()</script></paragraph><script>Pop()</script></column><ws data-child><script>{let element = Constructor(Space);element.Reactive={Before:1.401298464324817E-45,After:1.401298464324817E-45}}</script><script>Pop()</script></ws><script>Pop()</script></row><script>Pop()</script></column><script>Pop()</script></scroll-layout><script>Pop()</script><svg style="display:none;"><defs><image href="data:application/octet-stream;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAWACADASIAAhEBAxEB/8QAGQABAAMBAQAAAAAAAAAAAAAAAAEDBAUC/8QAFwEBAQEBAAAAAAAAAAAAAAAAAAIBA//aAAwDAQACEAMQAAAB025vXKp53TpAkgx//8QAGxAAAwEAAwEAAAAAAAAAAAAAAAECAxASIRP/2gAIAQEAAQUC+tE22a6XJeujJRXsNLq0KuE/Gz//xAAVEQEBAAAAAAAAAAAAAAAAAAAgIf/aAAgBAwEBPwGD/8QAFxEBAAMAAAAAAAAAAAAAAAAAAQACEP/aAAgBAgEBPwEsxd//xAAbEAABBAMAAAAAAAAAAAAAAAAAARARMQJBUf/aAAgBAQAGPwIs6baDF1mn/8QAGxAAAwADAQEAAAAAAAAAAAAAAAEREFFhgUH/2gAIAQEAAT8hU/gyjVeDOJ+MI4C6G3w7qTDrQ30ZSDIrbhJU/9oADAMBAAIAAwAAABAI0AP/xAAXEQADAQAAAAAAAAAAAAAAAAAAAREQ/9oACAEDAQE/EIIt/8QAFhEBAQEAAAAAAAAAAAAAAAAAAQAR/9oACAECAQE/EGMuwoy3/8QAHhABAAMAAgIDAAAAAAAAAAAAAQARITFxQVFhgaH/2gAIAQEAAT8QYNt1B7B4NSs8PpSdwJukeuWfsz21pPbK6hHLNVmtVsFM06mTWfLHs0ToK54fqGKlcvMuUtean//Z" id="7F76A4FA6725CA56"></image><filter id="A65402ECAD179F53"><feGaussianBlur stdDeviation="0 0.5"></feGaussianBlur></filter><filter id="A8D38B2D8722AFE8"><feGaussianBlur stdDeviation="0.5 0"></feGaussianBlur></filter></defs></svg></body></html>